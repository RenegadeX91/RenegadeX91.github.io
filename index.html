<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Temple Tile Simulator</title>
<script src="https://cdn.tailwindcss.com"></script>

<style>
  .cell {
    position: relative;
    width: 3rem;
    height: 3rem;
    background: #27272a;
    border-radius: 0.5rem;
  }

  .floor {
    position: absolute;
    inset: 0;
    border: 3px solid #98854d;
    border-radius: 0.5rem;
    background: #372f21;
    z-index: 1;
  }

  .open-U { border-top-color: transparent; }
  .open-R { border-right-color: transparent; }
  .open-D { border-bottom-color: transparent; }
  .open-L { border-left-color: transparent; }

  .room {
    position: absolute;
    inset: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 2;
    pointer-events: none;
  }

  .room img {
    width: 100%;
    height: 100%;
    object-fit: contain;
  }

  .faded {
    opacity: 0.6;
    filter: saturate(0.7);
  }

  .badge {
    position: absolute;
    top: -7px;
    left: -7px;
    z-index: 3;
    font-size: 10px;
    line-height: 1;
    padding: 3px 6px;
    border-radius: 999px;
    border: 1px solid rgba(255,255,255,0.25);
    background: rgba(0,0,0,0.55);
    color: rgba(255,255,255,0.85);
    pointer-events: none;
  }

  .badge-tier {
    position: absolute;
    bottom: -7px;
    right: -7px;
    z-index: 3;
    font-size: 10px;
    line-height: 1;
    padding: 3px 6px;
    border-radius: 999px;
    border: 1px solid rgba(255,255,255,0.25);
    background: rgba(0,0,0,0.55);
    color: rgba(255,255,255,0.9);
    pointer-events: none;
  }

  .badge-q {
    position: absolute;
    top: -7px;
    right: -7px;
    z-index: 3;
    font-size: 10px;
    line-height: 1;
    padding: 3px 6px;
    border-radius: 999px;
    border: 1px solid rgba(255,255,255,0.25);
    background: rgba(0,0,0,0.55);
    color: rgba(255,255,255,0.85);
    pointer-events: none;
  }

  /* Tier +/- controls (always in DOM; fade in on hover to avoid "vanishing") */
  .tier-controls {
    position: absolute;
    top: 2px;          /* INSIDE the cell so hover doesn't drop */
    left: 50%;
    z-index: 4;
    display: flex;
    gap: 4px;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.10s ease;
  }
  .cell:hover .tier-controls {
    opacity: 1;
    pointer-events: auto;
  }

  .tier-btn {
    width: 18px;
    height: 18px;
    border-radius: 999px;
    border: 1px solid rgba(255,255,255,0.25);
    background: rgba(0,0,0,0.70);
    color: rgba(255,255,255,0.95);
    font-size: 12px;
    line-height: 16px;
    font-weight: 700;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    user-select: none;
  }
  .tier-btn:hover { border-color: rgba(255,255,255,0.55); }

  /* =========================
     Diamond / 45° grid view
     ========================= */
  #grid-rot-wrap {
    padding: 80px; /* prevents diamond clipping */
    display: flex;
    justify-content: center;
    align-items: center;
  }

  #temple-grid {
    transform: rotate(45deg);
    transform-origin: center;
  }

  /* Keep icons/badges upright */
  #temple-grid .room,
  #temple-grid .badge,
  #temple-grid .badge-tier,
  #temple-grid .badge-q {
    transform: rotate(-45deg);
    transform-origin: center;
  }

  /* IMPORTANT: tier-controls needs translateX + rotate (avoid transform override bug) */
  #temple-grid .tier-controls {
    transform: translateX(-50%) rotate(-45deg);
    transform-origin: center;
  }

  .mini {
    font-size: 12px;
    opacity: 0.85;
  }
</style>
</head>

<body class="bg-zinc-900 text-zinc-100">
<div id="app" class="p-6"></div>

<script>
const GRID_SIZE = 9;
let selectedRoom = null;
let selectedFloor = null;
let planningMode = false;

const ENTRANCE = { r: GRID_SIZE - 1, c: Math.floor(GRID_SIZE / 2) }; // (8,4)
const entranceIndex = () => ENTRANCE.r * GRID_SIZE + ENTRANCE.c;

let uiMessage = "";
let suggestedMove = null; // { kind, index, step, roomKey, fromHand?, useUramot? }
let tutorialOpen = false;

/* ----------------------------
   Medallion + hand state
   ---------------------------- */
let medallions = {
  Jatalot: 0,
  Quipal: 0,
  Puaets: 0,
  Uramot: 0,
  Zopex: 0,
  Ascappers: 0
};

let useHandMode = false;
let consumeFloorsForAuto = false; // NEW: optionally consume floor tiles when solver auto-paths

// 6-card hand. Each entry can be:
// - room key (e.g. "Armoury")
// - floor key (e.g. "FLOOR:URDL")
// - null
let hand = Array(6).fill(null);

/* ----------------------------
   Grid model
   ---------------------------- */
let grid = Array(GRID_SIZE * GRID_SIZE).fill(null).map(() => ({
  room: null,
  floor: null,
  faded: false,
  tier: 1,
  locked: false,
  quipalUsed: false
}));

const FLOOR_TILES = [
  "U","R","D","L",
  "UR","RD","DL","LU","UD","LR",
  "URD","RDL","DLU","LUR",
  "URDL"
];

const FLOOR_KEY_TO_TILE = (() => {
  const map = {};
  for (const t of FLOOR_TILES) {
    const key = [...t].sort().join("");
    map[key] = t;
  }
  return map;
})();

const ROOM_NAMES = {
  Spymaster:"Spymaster",
  Garrison:"Garrison",
  LegionBarrack:"Legion Barracks",
  Commander:"Commander",
  FleshSurgeon:"Flesh Surgeon",
  Smithy:"Smithy",
  Armoury:"Armoury",
  SynthfleshLab:"Synthflesh Lab",
  TranscendentBarracks:"Transcendent Barracks",
  GolemWorks:"Golem Works",
  AlchemyLab:"Alchemy Lab",
  Thaumaturge:"Thaumaturge",
  CorruptionChamber:"Corruption Chamber",
  Generator:"Generator",
  SacrificialChamber:"Sacrificial Chamber",
  SealedVault:"Sealed Vault"
};

const ROOM_ICONS = {
  AlchemyLab:"icons/IconAlchemyLab.webp",
  Armoury:"icons/IconArmoury.webp",
  Commander:"icons/IconCommander.webp",
  CorruptionChamber:"icons/IconCorruption.webp",
  FleshSurgeon:"icons/IconFleshSurgeon.webp",
  Garrison:"icons/IconGarrison.webp",
  Generator:"icons/IconGenerator.webp",
  GolemWorks:"icons/IconGolemWorks.webp",
  SacrificialChamber:"icons/IconSacrificialChamber.webp",
  Smithy:"icons/IconSmithy.webp",
  SynthfleshLab:"icons/IconSynthflesh.webp",
  Thaumaturge:"icons/IconThaumaturge.webp",
  TranscendentBarracks:"icons/IconTranscendentBarracks.webp",
  SealedVault:"icons/IconVault.webp",
  LegionBarrack:"icons/IconViperLegionBarracks.webp",
  Spymaster:"icons/IconViperSpymaster.webp"
};

const ROOM_TILES = {
  Spymaster: { bonuses: ["MEDALLION:HIGH:LOCK"] },
  Garrison: { bonuses: ["20% Monster Packs", "30% Normal Monster Effectiveness"] },
  LegionBarrack: { bonuses: ["60% More Rare Monsters", "MEDALLION:HIGH:ADVANCED"] },
  Commander: { bonuses: ["60% Rare Monster Effectiveness", "MEDALLION:LOW:ADVANCED"] },
  FleshSurgeon: { bonuses: ["40% Unique Monster Effectiveness", "ITEM:Limb Modification"] },
  Smithy: { bonuses: ["60% Chest Item Rarity", "ITEM:Vaal Infuser"] },
  Armoury: { bonuses: ["60% Humanoid Monster Effectiveness"] },
  SynthfleshLab: { bonuses: ["40% Experience"] },
  TranscendentBarracks: { bonuses: ["60% More Magic Monsters"] },
  GolemWorks: { bonuses: ["ADD:High Priest", "MEDALLION:HIGH:ROOM"] },
  AlchemyLab: { bonuses: ["60% Item Rarity", "50% Gold", "ITEM:Core Destabiliser", "MEDALLION:LOW:ROOM"] },
  Thaumaturge: { bonuses: ["ADD:Quadrilla Sergeant", "ITEM:Crystallised Corruption", "MEDALLION:HIGH:ADVANCED"] },
  CorruptionChamber: { bonuses: ["60% Chance Rare Monster +1 Mod", "ADD:Royal Sentinel", "ITEM:Architect's Orb"] },
  Generator: { bonuses: ["60% Construct Monster Effectiveness", "ADD:Corrupted Abomination"] },
  SacrificialChamber: { bonuses: ["60% Increased Rare Chest", "ADD:Unchained Beast", "ITEM:Vaal Cultivation Orb", "MEDALLION:HIGH:ADVANCED"] },
  SealedVault: { bonuses: ["25% Item Rarity"] }
};

const BOOST_RULES = {
  Spymaster: { amount: 0.30, targets: ["Garrison", "Commander", "Armoury", "Smithy", "LegionBarrack"] },
  Thaumaturge: { amount: 0.30, targets: ["CorruptionChamber", "SealedVault", "SacrificialChamber"] }
};

function roman(n) {
  if (n === 1) return "I";
  if (n === 2) return "II";
  if (n === 3) return "III";
  return String(n);
}
function clampTier(t) { return Math.max(1, Math.min(3, t)); }
function tierPercentFactor(t) { return (t === 1) ? 0.25 : (t === 2) ? 0.50 : 1.00; }

function formatBonuses(tileKey, countPercent = 1, countFlat = 1) {
  return ROOM_TILES[tileKey]?.bonuses.map(b => {
    if (b.startsWith("MEDALLION:")) {
      const [, chance, type] = b.split(":");
      return `+${countFlat} ${chance === "HIGH" ? "High" : "Low"} Chance ${type} Medallion`;
    }
    if (b.startsWith("ITEM:")) return `+${countFlat} ${b.slice(5)}`;
    if (b.startsWith("ADD:")) return `Adds ${countFlat} ${b.slice(4)} to map`;
    const m = b.match(/(\d+)%\s*(.*)/);
    if (m) return `${Math.round(parseInt(m[1]) * countPercent)}% ${m[2]}`;
    return b;
  }) ?? [];
}
function categoryOf(text) {
  if (text.includes("Medallion")) return "Medallions";
  if (text.startsWith("+")) return "Items";
  if (text.startsWith("Adds")) return "Map Adds";
  if (text.includes("Monster")) return "Monster";
  return "Other";
}

/* ===============================
   Floor graph helpers
   =============================== */
const DIRS = {
  U: { dr: -1, dc: 0, opp: "D" },
  R: { dr: 0, dc: 1, opp: "L" },
  D: { dr: 1, dc: 0, opp: "U" },
  L: { dr: 0, dc: -1, opp: "R" }
};

function inBounds(r,c) { return r >= 0 && c >= 0 && r < GRID_SIZE && c < GRID_SIZE; }
function idx(r,c) { return r * GRID_SIZE + c; }
function rc(i) { return { r: Math.floor(i / GRID_SIZE), c: i % GRID_SIZE }; }
function opens(floorStr, dir) { return !!floorStr && floorStr.includes(dir); }

function neighborsOfIndex(i) {
  const { r, c } = rc(i);
  const out = [];
  for (const d of ["U","R","D","L"]) {
    const nr = r + DIRS[d].dr;
    const nc = c + DIRS[d].dc;
    if (!inBounds(nr,nc)) continue;
    out.push({ dir: d, index: idx(nr,nc) });
  }
  return out;
}

function floorEdgeExists(a, b) {
  const A = grid[a]?.floor;
  const B = grid[b]?.floor;
  if (!A || !B) return false;

  const ar = rc(a), br = rc(b);
  const dr = br.r - ar.r;
  const dc = br.c - ar.c;

  let dir = null;
  if (dr === -1 && dc === 0) dir = "U";
  else if (dr === 1 && dc === 0) dir = "D";
  else if (dr === 0 && dc === 1) dir = "R";
  else if (dr === 0 && dc === -1) dir = "L";
  else return false;

  const opp = DIRS[dir].opp;
  return opens(A, dir) && opens(B, opp);
}

function graphNeighbors(i) {
  const out = [];
  for (const n of neighborsOfIndex(i)) if (floorEdgeExists(i, n.index)) out.push(n.index);
  return out;
}

function connectedFromEntrance() {
  const start = entranceIndex();
  const visited = new Set([start]);
  const q = [start];
  while (q.length) {
    const cur = q.shift();
    for (const nxt of graphNeighbors(cur)) {
      if (visited.has(nxt)) continue;
      visited.add(nxt);
      q.push(nxt);
    }
  }
  return visited;
}

function entranceHasLoop() {
  const start = entranceIndex();
  const visited = new Set();
  const parent = new Map();
  const stack = [start];
  parent.set(start, null);

  while (stack.length) {
    const node = stack.pop();
    if (!visited.has(node)) visited.add(node);

    for (const nxt of graphNeighbors(node)) {
      if (!visited.has(nxt)) {
        parent.set(nxt, node);
        stack.push(nxt);
      } else {
        const p = parent.get(node);
        if (p !== nxt) return true;
      }
    }
  }
  return false;
}

function dirsToTileString(dirSet) {
  const key = [...dirSet].sort().join("");
  return FLOOR_KEY_TO_TILE[key] ?? null;
}
function addOpenOnMap(floorMap, i, dir) {
  const cur = floorMap[i] || null;
  const set = new Set(cur ? [...cur] : []);
  set.add(dir);
  floorMap[i] = dirsToTileString(set);
}
function connectCellsOnMap(floorMap, a, b) {
  const ar = rc(a), br = rc(b);
  const dr = br.r - ar.r;
  const dc = br.c - ar.c;

  let dir = null;
  if (dr === -1 && dc === 0) dir = "U";
  else if (dr === 1 && dc === 0) dir = "D";
  else if (dr === 0 && dc === 1) dir = "R";
  else if (dr === 0 && dc === -1) dir = "L";
  if (!dir) return;

  addOpenOnMap(floorMap, a, dir);
  addOpenOnMap(floorMap, b, DIRS[dir].opp);
}

/* ===============================
   Spymaster conversion
   =============================== */
function isActiveRoom(i, key) { return grid[i].room === key && !grid[i].faded; }
function hasActiveAdjacent(i, key) {
  for (const n of neighborsOfIndex(i)) if (isActiveRoom(n.index, key)) return true;
  return false;
}
function getEffectiveRoomKey(i) {
  const cell = grid[i];
  if (!cell.room || cell.faded) return cell.room;
  if (cell.room === "TranscendentBarracks" && hasActiveAdjacent(i, "Spymaster")) return "LegionBarrack";
  return cell.room;
}

/* ===============================
   Hand helpers
   =============================== */
function cardLabel(x) {
  if (!x) return "(empty)";
  if (x.startsWith("FLOOR:")) return `Path Tile: ${x.slice(6)}`;
  return ROOM_NAMES[x] || x;
}

function handCounts() {
  const m = {};
  for (const x of hand) {
    if (!x) continue;
    m[x] = (m[x] || 0) + 1;
  }
  return m;
}

function consumeCard(cardKey) {
  for (let i = 0; i < hand.length; i++) {
    if (hand[i] === cardKey) {
      hand[i] = null;
      return true;
    }
  }
  return false;
}

function payForMissingCards(requiredCards) {
  // requiredCards: array of exact keys e.g. ["Armoury", "FLOOR:UR", ...]
  const counts = handCounts();
  let missing = 0;
  for (const k of requiredCards) {
    if (!k) continue;
    if ((counts[k] || 0) > 0) counts[k] -= 1;
    else missing += 1;
  }
  if (missing > medallions.Uramot) return { ok: false, missing };
  return { ok: true, missing };
}

function consumeForRequiredCards(requiredCards) {
  // consume from hand if possible, otherwise consume Uramot as wildcard
  for (const k of requiredCards) {
    if (!k) continue;
    if (!consumeCard(k)) {
      if (medallions.Uramot > 0) medallions.Uramot -= 1;
      else return false;
    }
  }
  return true;
}

/* ===============================
   Auto-solvers paths
   =============================== */
const SNAKE_PATTERN = ["Armoury", "TranscendentBarracks", "Spymaster", "TranscendentBarracks"];
let cachedSnake = null;

function getSnakePath() {
  if (cachedSnake) return cachedSnake;

  const cols = [3,2,1,0];
  const path = [];
  let up = true;
  for (const col of cols) {
    if (up) for (let r = GRID_SIZE - 1; r >= 0; r--) path.push(idx(r, col));
    else for (let r = 0; r < GRID_SIZE; r++) path.push(idx(r, col));
    up = !up;
  }
  cachedSnake = path.filter(i => i !== entranceIndex());
  return cachedSnake;
}

/* ===============================
   Pattern Phase Detection (Syncs solver to board)
  
   =============================== */

// Helper: Match room types, treating Upgraded Barracks as valid matches for the base pattern
function roomsMatch(boardRoom, patternRoom) {
  if (!boardRoom) return false;
  if (boardRoom === patternRoom) return true;
  // Video Strategy: "Barracks" in the pattern can be Transcendent or Legion (upgraded)
  if ((boardRoom === "LegionBarrack" || boardRoom === "TranscendentBarracks") &&
      (patternRoom === "LegionBarrack" || patternRoom === "TranscendentBarracks")) {
    return true;
  }
  return false;
}

// Scans the board to find which "Phase" (rotation) of the snake pattern matches your existing rooms best.
function detectSnakePhase() {
  const path = getSnakePath();
  let bestOffset = 0;
  let maxScore = -Infinity;

  // Try all 4 possible rotations of the pattern to see which one fits your board
  for (let offset = 0; offset < SNAKE_PATTERN.length; offset++) {
    let matches = 0;
    let mismatches = 0;
    let hasRoom = false;

    for (let step = 0; step < path.length; step++) {
      const i = path[step];
      const cellRoom = grid[i].room;
      if (!cellRoom) continue; // Ignore empty slots

      hasRoom = true;
      const expected = SNAKE_PATTERN[(step + offset) % SNAKE_PATTERN.length];
      
      if (roomsMatch(cellRoom, expected)) {
        matches++;
      } else {
        mismatches++;
      }
    }

    // Score favors matches and heavily penalizes mismatches
    const score = hasRoom ? (matches - (mismatches * 2)) : 0;

    if (score > maxScore) {
      maxScore = score;
      bestOffset = offset;
    }
  }

  // Default to 0 (Armoury start) if board is empty or ambiguous
  if (maxScore <= 0 && bestOffset === 0) return 0;
  return bestOffset;
}

function expectedSnakeRoom(step, offset = 0) { 
  return SNAKE_PATTERN[(step + offset) % SNAKE_PATTERN.length]; 
}

function snakeFirstEmptyStep() {
  const path = getSnakePath();
  for (let step = 0; step < path.length; step++) if (!grid[path[step]].room) return step;
  return null;
}

function validateSnakePrefix() {
  const path = getSnakePath();
  const offset = detectSnakePhase(); // Auto-detect phase
  const mismatches = [];
  
  for (let step = 0; step < path.length; step++) {
    const i = path[step];
    const room = grid[i].room;
    if (!room) break;
    
    const exp = expectedSnakeRoom(step, offset);
    // Use the robust matcher (handles Legion/Transcendent equivalence)
    if (!roomsMatch(room, exp)) {
      mismatches.push({ step, index: i, expected: exp, found: room });
    }
  }
  return mismatches;
}

const CORRUPT_PATTERN = ["Generator", "SacrificialChamber", "Thaumaturge", "CorruptionChamber", "AlchemyLab", "SealedVault"];
let cachedCorrupt = null;

function getCorruptionPath() {
  if (cachedCorrupt) return cachedCorrupt;

  const coords = [
    { r: GRID_SIZE - 1, c: 5 },
    { r: GRID_SIZE - 2, c: 5 },
    { r: GRID_SIZE - 3, c: 5 },
    { r: GRID_SIZE - 4, c: 5 },
    { r: GRID_SIZE - 5, c: 5 },
    { r: GRID_SIZE - 6, c: 5 },
  ];
  cachedCorrupt = coords
    .filter(p => inBounds(p.r, p.c))
    .map(p => idx(p.r, p.c))
    .filter(i => i !== entranceIndex());
  return cachedCorrupt;
}
function expectedCorruptRoom(step) { return CORRUPT_PATTERN[step % CORRUPT_PATTERN.length]; }
function corruptFirstEmptyStep() {
  const path = getCorruptionPath();
  for (let step = 0; step < path.length; step++) if (!grid[path[step]].room) return step;
  return null;
}
function validateCorruptionPrefix() {
  const path = getCorruptionPath();
  const mismatches = [];
  for (let step = 0; step < path.length; step++) {
    const i = path[step];
    const room = grid[i].room;
    if (!room) break;
    const exp = expectedCorruptRoom(step);
    if (room !== exp) mismatches.push({ step, index: i, expected: exp, found: room });
  }
  return mismatches;
}

/* ===============================
   Auto-floor planning (hand-aware)
   =============================== */
function planFloorsForSnake(uptoStepInclusive) {
  const floorMap = {};
  for (let i = 0; i < grid.length; i++) floorMap[i] = grid[i].floor || null;

  const path = getSnakePath();
  if (uptoStepInclusive === null || uptoStepInclusive < 0) return floorMap;

  // Entrance -> first snake tile
  connectCellsOnMap(floorMap, entranceIndex(), path[0]);
  // Along snake
  for (let step = 0; step < uptoStepInclusive; step++) connectCellsOnMap(floorMap, path[step], path[step + 1]);

  return floorMap;
}

function planFloorsForCorruption(uptoStepInclusive) {
  const floorMap = {};
  for (let i = 0; i < grid.length; i++) floorMap[i] = grid[i].floor || null;

  const path = getCorruptionPath();
  if (uptoStepInclusive === null || uptoStepInclusive < 0) return floorMap;

  connectCellsOnMap(floorMap, entranceIndex(), path[0]);
  for (let step = 0; step < uptoStepInclusive; step++) connectCellsOnMap(floorMap, path[step], path[step + 1]);

  return floorMap;
}

function floorsDeltaAsRequiredCards(newFloorMap) {
  // Returns list of required floor cards for changed cells (approx model).
  const req = [];
  for (let i = 0; i < grid.length; i++) {
    const oldF = grid[i].floor || null;
    const newF = newFloorMap[i] || null;
    if (newF === oldF) continue;
    if (!newF) continue; // clearing floors doesn't cost
    req.push(`FLOOR:${newF}`);
  }
  return req;
}

function applyFloorPlan(newFloorMap, requiredCards) {
  // Optionally consume from hand (or Uramot wildcard), then apply the floors.
  if (useHandMode && consumeFloorsForAuto) {
    const pay = payForMissingCards(requiredCards);
    if (!pay.ok) {
      uiMessage = `Not enough pathing tiles in hand. Missing ${pay.missing} tile(s) and only have ${medallions.Uramot} Uramot wildcard(s).`;
      return false;
    }
    if (!consumeForRequiredCards(requiredCards)) {
      uiMessage = "Failed to consume required floor cards.";
      return false;
    }
  }

  for (let i = 0; i < grid.length; i++) {
    const oldF = grid[i].floor || null;
    const newF = newFloorMap[i] || null;
    if (newF === oldF) continue;
    grid[i].floor = newF;
  }
  return true;
}

/* ---- Hand-aware suggestions ---- */
function suggestNext(kind) {
  if (kind === "snake") {
    const path = getSnakePath();
    const offset = detectSnakePhase(); // <--- KEY FIX: Sync with board state
    const mismatches = validateSnakePrefix();
    
    // Find the first empty step (gap) to fill or extend
    const step = snakeFirstEmptyStep();
    if (step === null) return { ok: false, reason: "Snake path is full." };
    
    const i = path[step];
    
    // Predict the next room based on the detected phase
    const roomKey = expectedSnakeRoom(step, offset);

    if (useHandMode) {
      const counts = handCounts();
      // Check if we have the needed room (or if we need Barracks, do we have Legion?)
      const hasCard = (counts[roomKey] || 0) > 0;
      
      // Strict hand check:
      if (hasCard) {
        return { ok: true, move: { kind, index: i, step, roomKey, fromHand: true }, warn: mismatches.length ? mismatches : null };
      }
      if (medallions.Uramot > 0) {
        return { ok: true, move: { kind, index: i, step, roomKey, useUramot: true }, warn: mismatches.length ? mismatches : null };
      }
      return { 
        ok: false, 
        reason: `Autosnake (Phase ${offset}): Needs ${ROOM_NAMES[roomKey]} but it isn't in your hand. Use Puaets to reroll, or Uramot wildcard.` 
      };
    }

    return { ok: true, move: { kind, index: i, step, roomKey }, warn: mismatches.length ? mismatches : null };
  }

  if (kind === "corrupt") {
    const path = getCorruptionPath();
    const mismatches = validateCorruptionPrefix();
    const step = corruptFirstEmptyStep();
    if (step === null) return { ok: false, reason: "Corruption path is full." };
    const i = path[step];
    const roomKey = expectedCorruptRoom(step);

    if (useHandMode) {
      const counts = handCounts();
      if ((counts[roomKey] || 0) > 0) return { ok: true, move: { kind, index: i, step, roomKey, fromHand: true }, warn: mismatches.length ? mismatches : null };
      if (medallions.Uramot > 0) return { ok: true, move: { kind, index: i, step, roomKey, useUramot: true }, warn: mismatches.length ? mismatches : null };
      return { ok: false, reason: `Need ${ROOM_NAMES[roomKey]} but it isn't in your hand. Use Puaets to reroll, or Uramot wildcard to place anyway.` };
    }

    return { ok: true, move: { kind, index: i, step, roomKey }, warn: mismatches.length ? mismatches : null };
  }

  return { ok: false, reason: "Unknown kind" };
}

function setSuggestionOnly(s) {
  if (!s.ok) { uiMessage = s.reason; suggestedMove = null; return; }
  suggestedMove = s.move;

  const warn = s.warn || [];
  if (warn.length) {
    const first = warn[0];
    uiMessage = `Suggested ${s.move.kind} step ${s.move.step + 1}: ${ROOM_NAMES[s.move.roomKey]}. Warning: mismatch at step ${first.step + 1} (expected ${ROOM_NAMES[first.expected]}, found ${ROOM_NAMES[first.found]}).`;
  } else {
    uiMessage = `Suggested ${s.move.kind} step ${s.move.step + 1}: ${ROOM_NAMES[s.move.roomKey]} at (${rc(s.move.index).r},${rc(s.move.index).c}).`;
  }
}

function applySuggestion(s) {
  if (!s.ok) { uiMessage = s.reason; suggestedMove = null; return; }
  suggestedMove = s.move;

  const { kind, index, step, roomKey, fromHand, useUramot } = s.move;

  if (grid[index].room && grid[index].room !== roomKey) {
    uiMessage = `Target cell already has ${ROOM_NAMES[grid[index].room]} (expected ${ROOM_NAMES[roomKey]}). Clear it first.`;
    return;
  }

  // Pay for room card in hand-mode
  if (useHandMode) {
    if (fromHand) {
      if (!consumeCard(roomKey)) { uiMessage = `Couldn't consume ${ROOM_NAMES[roomKey]} from hand.`; return; }
    } else if (useUramot) {
      if (medallions.Uramot <= 0) { uiMessage = "No Uramot wildcard available."; return; }
      medallions.Uramot -= 1;
    } else {
      uiMessage = "Internal: hand-mode move must be fromHand or useUramot.";
      return;
    }
  }

  // Place room
  grid[index].room = roomKey;
  grid[index].faded = planningMode;
  grid[index].tier = 1;
  grid[index].locked = false;
  grid[index].quipalUsed = false;

  // Apply floors (hand-aware if enabled)
  let floorPlan = null;
  if (kind === "snake") floorPlan = planFloorsForSnake(step);
  if (kind === "corrupt") floorPlan = planFloorsForCorruption(step);

  if (floorPlan) {
    const requiredFloorCards = floorsDeltaAsRequiredCards(floorPlan);
    if (!applyFloorPlan(floorPlan, requiredFloorCards)) { render(); return; }
  }

  const warn = s.warn || [];
  if (warn.length) {
    const first = warn[0];
    uiMessage = `Placed ${kind} step ${step + 1}, but mismatch earlier at step ${first.step + 1} (expected ${ROOM_NAMES[first.expected]}, found ${ROOM_NAMES[first.found]}).`;
  } else {
    uiMessage = `Placed ${kind} step ${step + 1}: ${ROOM_NAMES[roomKey]} at (${rc(index).r},${rc(index).c}).`;
  }
}

/* ===============================
   Medallion advice engine (with crash fix)
   =============================== */
function findIndices(predicate) {
  const out = [];
  for (let i = 0; i < grid.length; i++) if (predicate(i, grid[i])) out.push(i);
  return out;
}

function getMedallionAdvice(connected) {
  const advice = [];

  // Jatalot: lock key rooms
  if (medallions.Jatalot > 0) {
    const snakeRoot = getSnakePath()[0];
    const corruptRoot = getCorruptionPath()[0];

    if (grid[snakeRoot]?.room && !grid[snakeRoot].locked) {
      advice.push({
        key: "lock-snake-root",
        text: `Use Jatalot to LOCK Snake root (${ROOM_NAMES[grid[snakeRoot].room]}) at (${rc(snakeRoot).r},${rc(snakeRoot).c}).`,
        canApply: true,
        apply: () => {
          if (medallions.Jatalot <= 0) return;
          grid[snakeRoot].locked = true;
          medallions.Jatalot -= 1;
          uiMessage = "Locked Snake root (Jatalot).";
        }
      });
    } else if (grid[corruptRoot]?.room && !grid[corruptRoot].locked) {
      advice.push({
        key: "lock-corrupt-root",
        text: `Use Jatalot to LOCK Corruption root (${ROOM_NAMES[grid[corruptRoot].room]}) at (${rc(corruptRoot).r},${rc(corruptRoot).c}).`,
        canApply: true,
        apply: () => {
          if (medallions.Jatalot <= 0) return;
          grid[corruptRoot].locked = true;
          medallions.Jatalot -= 1;
          uiMessage = "Locked Corruption root (Jatalot).";
        }
      });
    }

    const sac = findIndices((i,c) => c.room === "SacrificialChamber" && !c.faded && connected.has(i) && !c.locked)[0];
    if (sac !== undefined) {
      advice.push({
        key: "lock-sac",
        text: `Use Jatalot to LOCK Sacrificial Chamber at (${rc(sac).r},${rc(sac).c}).`,
        canApply: true,
        apply: () => {
          if (medallions.Jatalot <= 0) return;
          grid[sac].locked = true;
          medallions.Jatalot -= 1;
          uiMessage = "Locked Sacrificial Chamber (Jatalot).";
        }
      });
    }
  }

  // Quipal: upgrade suggestions (CRASH FIX + cap)
  if (medallions.Quipal > 0) {
    const candidates = [];
    for (let i = 0; i < grid.length; i++) {
      const c = grid[i];
      if (!c.room || c.faded) continue;
      if (!connected.has(i)) continue;
      if ((c.tier || 1) >= 3) continue;
      if (c.quipalUsed) continue;

      const eff = getEffectiveRoomKey(i) || c.room;
      let prio = 50;

      if (eff === "Spymaster") prio = 1;
      else if (eff === "LegionBarrack") prio = 2;
      else if (eff === "SacrificialChamber") prio = 3;
      else if (eff === "Thaumaturge") prio = 4;
      else if (eff === "CorruptionChamber") prio = 5;
      else if (eff === "Armoury") prio = 6;

      candidates.push({ i, prio, eff, tier: c.tier || 1 });
    }

    candidates.sort((a,b) => a.prio - b.prio);

    const max = Math.min(medallions.Quipal, candidates.length, 10);
    for (let k = 0; k < max; k++) {
      const c = candidates[k];
      const name = ROOM_NAMES[c.eff] || c.eff;

      advice.push({
        key: `quipal-${c.i}`,
        text: `Use Quipal to upgrade ${name} at (${rc(c.i).r},${rc(c.i).c}) from ${roman(c.tier)} → ${roman(c.tier+1)}.`,
        canApply: true,
        apply: () => {
          if (medallions.Quipal <= 0) return;
          if (grid[c.i].quipalUsed) { uiMessage = "Quipal already used on that room."; return; }
          grid[c.i].tier = clampTier((grid[c.i].tier || 1) + 1);
          grid[c.i].quipalUsed = true;
          medallions.Quipal -= 1;
          uiMessage = `Applied Quipal at (${rc(c.i).r},${rc(c.i).c}).`;
        }
      });
    }
  }

  // Hand-mode: recommend Puaets reroll if blocked
  if (useHandMode) {
    const nextSnake = suggestNext("snake");
    const nextCorrupt = suggestNext("corrupt");
    const needSnake = !nextSnake.ok && /Need/.test(nextSnake.reason || "");
    const needCorrupt = !nextCorrupt.ok && /Need/.test(nextCorrupt.reason || "");

    if ((needSnake || needCorrupt) && medallions.Puaets > 0) {
      advice.push({
        key: "puaets-reroll",
        text: "Use Puaets to REROLL your 6 cards (your next required room isn’t in hand).",
        canApply: true,
        apply: () => {
          if (medallions.Puaets <= 0) return;
          medallions.Puaets -= 1;
          hand = Array(6).fill(null);
          uiMessage = "Used Puaets: hand cleared. Enter your new 6 cards.";
        }
      });
    }
  }

  return advice;
}

/* ===============================
   Layout helpers
   =============================== */
function clearAllRoomsAndFloors() {
  grid.forEach(c => {
    c.room = null;
    c.floor = null;
    c.faded = false;
    c.tier = 1;
    c.locked = false;
    c.quipalUsed = false;
  });
  suggestedMove = null;
}

function rebuildFloorsForAllPlaced() {
  // clear then rebuild floors based on currently placed prefixes
  const snakePath = getSnakePath();
  let snakeUpto = -1;
  for (let step = 0; step < snakePath.length; step++) {
    if (!grid[snakePath[step]].room) break;
    snakeUpto = step;
  }

  const corruptPath = getCorruptionPath();
  let corruptUpto = -1;
  for (let step = 0; step < corruptPath.length; step++) {
    if (!grid[corruptPath[step]].room) break;
    corruptUpto = step;
  }

  // build floor plan from scratch (ignores current floors)
  const newFloorMap = {};
  for (let i = 0; i < grid.length; i++) newFloorMap[i] = null;

  if (snakeUpto >= 0) {
    const tmp = {};
    for (let i = 0; i < grid.length; i++) tmp[i] = newFloorMap[i];
    const p = getSnakePath();
    connectCellsOnMap(tmp, entranceIndex(), p[0]);
    for (let step = 0; step < snakeUpto; step++) connectCellsOnMap(tmp, p[step], p[step + 1]);
    for (let i = 0; i < grid.length; i++) newFloorMap[i] = tmp[i];
  }

  if (corruptUpto >= 0) {
    const tmp = {};
    for (let i = 0; i < grid.length; i++) tmp[i] = newFloorMap[i];
    const p = getCorruptionPath();
    connectCellsOnMap(tmp, entranceIndex(), p[0]);
    for (let step = 0; step < corruptUpto; step++) connectCellsOnMap(tmp, p[step], p[step + 1]);
    for (let i = 0; i < grid.length; i++) newFloorMap[i] = tmp[i];
  }

  // if consuming floors for auto, charge for all non-null tiles (since we rebuild)
  let required = [];
  if (useHandMode && consumeFloorsForAuto) {
    // treat as "set floors from scratch": require for any non-null floor set
    for (let i = 0; i < grid.length; i++) {
      const newF = newFloorMap[i];
      if (!newF) continue;
      // only charge if it actually changes from current
      if ((grid[i].floor || null) !== newF) required.push(`FLOOR:${newF}`);
    }
  }

  // Apply (will also consume if enabled)
  if (!applyFloorPlan(newFloorMap, required)) return;

  uiMessage = "Rebuilt floors for placed Snake + Corruption prefixes.";
  suggestedMove = null;
}

/* ===============================
   Save / load (includes medallions + hand + floor settings)
   =============================== */
function saveLayout() {
  const payload = { version: 4, grid, medallions, useHandMode, consumeFloorsForAuto, hand, planningMode };
  navigator.clipboard.writeText(JSON.stringify(payload));
  alert("Layout copied to clipboard");
}

function loadLayout() {
  const input = prompt("Paste layout data:");
  if (!input) return;

  try {
    const parsed = JSON.parse(input);

    // legacy: raw grid array
    if (Array.isArray(parsed) && parsed.length === GRID_SIZE * GRID_SIZE) {
      grid = parsed.map(c => ({
        room: c.room ?? null,
        floor: c.floor ?? null,
        faded: !!c.faded,
        tier: c.tier ?? 1,
        locked: !!c.locked,
        quipalUsed: !!c.quipalUsed
      }));
      uiMessage = "Loaded (legacy) layout.";
      suggestedMove = null;
      render();
      return;
    }

    if (parsed && parsed.grid && Array.isArray(parsed.grid) && parsed.grid.length === GRID_SIZE * GRID_SIZE) {
      grid = parsed.grid.map(c => ({
        room: c.room ?? null,
        floor: c.floor ?? null,
        faded: !!c.faded,
        tier: c.tier ?? 1,
        locked: !!c.locked,
        quipalUsed: !!c.quipalUsed
      }));

      medallions = { ...medallions, ...(parsed.medallions || {}) };
      useHandMode = !!parsed.useHandMode;
      consumeFloorsForAuto = !!parsed.consumeFloorsForAuto;
      hand = Array.isArray(parsed.hand) ? parsed.hand.slice(0,6).concat(Array(6).fill(null)).slice(0,6) : Array(6).fill(null);
      planningMode = !!parsed.planningMode;

      uiMessage = "Loaded layout.";
      suggestedMove = null;
      render();
    }
  } catch {}
}

/* ===============================
   Render
   =============================== */
function render() {
  const app = document.getElementById("app");
  app.innerHTML = "";

  const container = document.createElement("div");
  container.className = "flex gap-6";

  const connected = connectedFromEntrance();
  const hasLoop = entranceHasLoop();

  // Advice can never hard-crash the page now
  let advice = [];
  try { advice = getMedallionAdvice(connected); }
  catch (e) { uiMessage = "Error in medallion advice engine. Check console."; console.error(e); advice = []; }

  const gridCol = document.createElement("div");

  /* ---------- GRID ---------- */
  const gridWrap = document.createElement("div");
  gridWrap.id = "grid-rot-wrap";

  const gridEl = document.createElement("div");
  gridEl.id = "temple-grid";
  gridEl.className = "grid grid-cols-9 gap-2";

  grid.forEach((cell, i) => {
    const btn = document.createElement("button");
    btn.className = "cell";

    if (i === entranceIndex()) btn.classList.add("ring-2","ring-sky-400");
    if (suggestedMove && i === suggestedMove.index) btn.classList.add("ring-2","ring-amber-400");
    if (cell.room && !connected.has(i)) btn.classList.add("ring-2","ring-red-500");
    if (cell.locked) btn.classList.add("ring-1","ring-amber-200");

    if (cell.floor) {
      const f = document.createElement("div");
      f.className = "floor " + [...cell.floor].map(d => "open-" + d).join(" ");
      btn.appendChild(f);
    }

    // Tier controls only if there is a room
    if (cell.room) {
      const tc = document.createElement("div");
      tc.className = "tier-controls";

      const minus = document.createElement("div");
      minus.className = "tier-btn";
      minus.textContent = "–";
      minus.title = "Tier down";
      minus.onclick = (e) => {
        e.preventDefault();
        e.stopPropagation();
        cell.tier = clampTier((cell.tier || 1) - 1);
        uiMessage = `Tier down: (${rc(i).r},${rc(i).c}) is now ${roman(cell.tier)}.`;
        suggestedMove = null;
        render();
      };

      const plus = document.createElement("div");
      plus.className = "tier-btn";
      plus.textContent = "+";
      plus.title = "Tier up";
      plus.onclick = (e) => {
        e.preventDefault();
        e.stopPropagation();
        cell.tier = clampTier((cell.tier || 1) + 1);
        uiMessage = `Tier up: (${rc(i).r},${rc(i).c}) is now ${roman(cell.tier)}.`;
        suggestedMove = null;
        render();
      };

      tc.append(minus, plus);
      btn.appendChild(tc);

      const eff = getEffectiveRoomKey(i) || cell.room;

      const r = document.createElement("div");
      r.className = "room";
      const img = document.createElement("img");
      img.src = ROOM_ICONS[eff] || ROOM_ICONS[cell.room];
      r.appendChild(img);
      btn.appendChild(r);

      if (cell.locked) {
        const b = document.createElement("div");
        b.className = "badge";
        b.textContent = "LOCK";
        btn.appendChild(b);
      }

      if (cell.quipalUsed) {
        const bq = document.createElement("div");
        bq.className = "badge-q";
        bq.textContent = "Q";
        btn.appendChild(bq);
      }

      const bt = document.createElement("div");
      bt.className = "badge-tier";
      bt.textContent = roman(cell.tier || 1);
      btn.appendChild(bt);

      if (!cell.faded && cell.room === "TranscendentBarracks" && eff === "LegionBarrack") {
        const b2 = document.createElement("div");
        b2.className = "badge";
        b2.style.left = "26px";
        b2.textContent = "LEGION";
        btn.appendChild(b2);
      }
    }

    if (cell.faded) btn.classList.add("faded");

    const eff = getEffectiveRoomKey(i);
    const connText = cell.room ? (connected.has(i) ? "connected" : "DISCONNECTED") : "empty";
    const floorText = cell.floor ? cell.floor : "(no floor)";
    const roomText = cell.room ? (ROOM_NAMES[cell.room] || cell.room) : "(no room)";
    const effText = (cell.room && eff && eff !== cell.room) ? ` (effective: ${ROOM_NAMES[eff] || eff})` : "";
    const lockText = cell.locked ? "LOCKED" : "unlocked";
    btn.title =
      `${roomText}${effText}\nTier: ${roman(cell.tier || 1)}\n${lockText}\nFloor: ${floorText}\nStatus: ${connText}\nPos: (${rc(i).r},${rc(i).c})\n\nControls:\n- Shift+Click: tier up\n- Alt+Click: tier down\n- Hover: +/- buttons\n- Right-click: clear (Shift+Right-click clears even if locked)`;

    btn.onclick = (e) => {
      // Tier editing always wins if a room exists
      if (cell.room && (e.shiftKey || e.altKey)) {
        if (e.shiftKey) {
          cell.tier = clampTier((cell.tier || 1) + 1);
          uiMessage = `Tier up: (${rc(i).r},${rc(i).c}) is now ${roman(cell.tier)}.`;
        } else if (e.altKey) {
          cell.tier = clampTier((cell.tier || 1) - 1);
          uiMessage = `Tier down: (${rc(i).r},${rc(i).c}) is now ${roman(cell.tier)}.`;
        }
        suggestedMove = null;
        render();
        return;
      }

      // Manual room placement
      if (selectedRoom) {
        // In hand mode, placing a room should consume that room card (or Uramot wildcard)
        if (useHandMode) {
          const counts = handCounts();
          if ((counts[selectedRoom] || 0) > 0) {
            consumeCard(selectedRoom);
          } else if (medallions.Uramot > 0) {
            medallions.Uramot -= 1;
          } else {
            uiMessage = `Can't place ${ROOM_NAMES[selectedRoom]}: not in hand (and no Uramot wildcard).`;
            render();
            return;
          }
        }

        cell.room = selectedRoom;
        cell.faded = planningMode;
        cell.tier = 1;
        cell.locked = false;
        cell.quipalUsed = false;
        suggestedMove = null;
        render();
        return;
      }

      // Manual floor placement
      if (selectedFloor) {
        const cardKey = `FLOOR:${selectedFloor}`;

        if (useHandMode) {
          const counts = handCounts();
          if ((counts[cardKey] || 0) > 0) {
            consumeCard(cardKey);
          } else if (medallions.Uramot > 0) {
            medallions.Uramot -= 1;
          } else {
            uiMessage = `Can't place path tile ${selectedFloor}: not in hand (and no Uramot wildcard).`;
            render();
            return;
          }
        }

        cell.floor = selectedFloor;
        suggestedMove = null;
        render();
        return;
      }

      // Toggle faded (planning)
      cell.faded = !cell.faded;
      render();
    };

    btn.oncontextmenu = e => {
      e.preventDefault();
      if (cell.locked && !e.shiftKey) {
        uiMessage = "That room is LOCKED. Shift+Right-click to clear anyway.";
        render();
        return;
      }

      cell.room = null;
      cell.floor = null;
      cell.faded = false;
      cell.tier = 1;
      cell.locked = false;
      cell.quipalUsed = false;
      suggestedMove = null;
      render();
    };

    gridEl.appendChild(btn);
  });

  gridWrap.appendChild(gridEl);
  gridCol.appendChild(gridWrap);

  /* ---------- FLOOR PALETTE (below grid) ---------- */
  const floorWrap = document.createElement("div");
  floorWrap.className = "mt-2 text-center";

  const floorTitle = document.createElement("div");
  floorTitle.className = "text-xs opacity-80 mb-2";
  floorTitle.textContent = "Pathing tiles (floors)";

  const floorGrid = document.createElement("div");
  floorGrid.className = "grid grid-cols-5 gap-2 justify-center";

  FLOOR_TILES.forEach(f => {
    const b = document.createElement("button");
    b.className = "cell";
    if (selectedFloor === f) b.classList.add("ring-2","ring-emerald-500");

    const d = document.createElement("div");
    d.className = "floor " + [...f].map(x => "open-" + x).join(" ");
    b.appendChild(d);

    b.onclick = () => {
      selectedFloor = selectedFloor === f ? null : f;
      selectedRoom = null;
      render();
    };

    floorGrid.appendChild(b);
  });

  floorWrap.append(floorTitle, floorGrid);
  gridCol.appendChild(floorWrap);

  /* ---------- CONTROLS ---------- */
  const controls = document.createElement("div");
  controls.className = "flex flex-col gap-2 mt-3";

  const row1 = document.createElement("div");
  row1.className = "flex gap-2 flex-wrap";

  const saveBtn = document.createElement("button");
  saveBtn.textContent = "Save";
  saveBtn.className = "px-3 py-1 bg-zinc-700 rounded";
  saveBtn.onclick = saveLayout;

  const loadBtn = document.createElement("button");
  loadBtn.textContent = "Load";
  loadBtn.className = "px-3 py-1 bg-zinc-700 rounded";
  loadBtn.onclick = loadLayout;

  const planning = document.createElement("label");
  planning.className = "flex items-center gap-2 text-sm px-2";
  const cb = document.createElement("input");
  cb.type = "checkbox";
  cb.checked = planningMode;
  cb.onchange = e => { planningMode = e.target.checked; render(); };
  planning.append(cb, document.createTextNode("Planning mode"));

  const resetBtn = document.createElement("button");
  resetBtn.textContent = "Clear all";
  resetBtn.className = "px-3 py-1 bg-zinc-700 rounded";
  resetBtn.onclick = () => { clearAllRoomsAndFloors(); uiMessage = "Cleared all rooms and floors."; render(); };

  row1.append(saveBtn, loadBtn, planning, resetBtn);

  const row2 = document.createElement("div");
  row2.className = "flex gap-2 flex-wrap items-center";

  const snakeLabel = document.createElement("div");
  snakeLabel.className = "text-sm font-semibold text-emerald-300";
  snakeLabel.textContent = "Spymaster Snake:";

  const snakeSuggestBtn = document.createElement("button");
  snakeSuggestBtn.textContent = "Suggest";
  snakeSuggestBtn.className = "px-3 py-1 bg-emerald-700 rounded";
  snakeSuggestBtn.onclick = () => { setSuggestionOnly(suggestNext("snake")); render(); };

  const snakeStepBtn = document.createElement("button");
  snakeStepBtn.textContent = "Auto place 1";
  snakeStepBtn.className = "px-3 py-1 bg-emerald-700 rounded";
  snakeStepBtn.onclick = () => { applySuggestion(suggestNext("snake")); render(); };

  const corruptLabel = document.createElement("div");
  corruptLabel.className = "text-sm font-semibold text-sky-300 ml-2";
  corruptLabel.textContent = "Corruption package:";

  const corruptSuggestBtn = document.createElement("button");
  corruptSuggestBtn.textContent = "Suggest";
  corruptSuggestBtn.className = "px-3 py-1 bg-sky-700 rounded";
  corruptSuggestBtn.onclick = () => { setSuggestionOnly(suggestNext("corrupt")); render(); };

  const corruptStepBtn = document.createElement("button");
  corruptStepBtn.textContent = "Auto place 1";
  corruptStepBtn.className = "px-3 py-1 bg-sky-700 rounded";
  corruptStepBtn.onclick = () => { applySuggestion(suggestNext("corrupt")); render(); };

  const rebuildFloorsBtn = document.createElement("button");
  rebuildFloorsBtn.textContent = "Rebuild floors";
  rebuildFloorsBtn.className = "px-3 py-1 bg-zinc-700 rounded";
  rebuildFloorsBtn.onclick = () => { rebuildFloorsForAllPlaced(); render(); };

  row2.append(snakeLabel, snakeSuggestBtn, snakeStepBtn, corruptLabel, corruptSuggestBtn, corruptStepBtn, rebuildFloorsBtn);

  const status = document.createElement("div");
  status.className = "text-xs mt-1 opacity-80";

  const nActiveRooms = grid.filter(c => c.room && !c.faded).length;
  const nConnectedActiveRooms = grid.map((c,i) => ({ c, i })).filter(x => x.c.room && !x.c.faded && connected.has(x.i)).length;

  status.innerHTML = `
    <div>
      Entrance: (${ENTRANCE.r},${ENTRANCE.c}) |
      Active rooms: <span class="text-zinc-100">${nActiveRooms}</span> |
      Connected to entrance: <span class="text-zinc-100">${nConnectedActiveRooms}</span> |
      Loop: ${hasLoop ? "<span class='text-red-400 font-semibold'>DETECTED</span>" : "<span class='text-emerald-300'>none</span>"}
    </div>
    <div class="mt-1">${uiMessage ? uiMessage : ""}</div>
    <div class="mt-1">Tier: Shift/Alt, or hover +/- buttons. (Red outline = not connected.)</div>
  `;

  /* ---------- Medallions + Hand panel ---------- */
  const medBox = document.createElement("div");
  medBox.className = "mt-3 p-3 bg-zinc-800 rounded border border-zinc-700";

  const medTitle = document.createElement("div");
  medTitle.className = "font-semibold mb-2 text-amber-300";
  medTitle.textContent = "Medallions + Hand";

  const medRow = document.createElement("div");
  medRow.className = "grid grid-cols-2 gap-2";

  function medInput(key, label) {
    const wrap = document.createElement("label");
    wrap.className = "text-xs flex items-center justify-between gap-2 bg-zinc-900 border border-zinc-700 rounded px-2 py-2";

    const t = document.createElement("div");
    t.textContent = label;

    const inp = document.createElement("input");
    inp.type = "number";
    inp.min = "0";
    inp.value = String(medallions[key] ?? 0);
    inp.className = "w-20 px-2 py-1 bg-zinc-800 rounded border border-zinc-700 text-xs";
    inp.onchange = (e) => {
      medallions[key] = Math.max(0, parseInt(e.target.value || "0", 10));
      render();
    };

    wrap.append(t, inp);
    return wrap;
  }

  medRow.append(
    medInput("Jatalot", "Jatalot (Lock)"),
    medInput("Quipal", "Quipal (+1 Tier)"),
    medInput("Puaets", "Puaets (Reroll Hand)"),
    medInput("Uramot", "Uramot (Wildcard)"),
    medInput("Zopex", "Zopex (Meta)"),
    medInput("Ascappers", "Ascappers (Meta)")
  );

  const handRow = document.createElement("div");
  handRow.className = "mt-3";

  const handToggle = document.createElement("label");
  handToggle.className = "text-xs flex items-center gap-2";
  const ht = document.createElement("input");
  ht.type = "checkbox";
  ht.checked = useHandMode;
  ht.onchange = (e) => { useHandMode = e.target.checked; render(); };
  handToggle.append(ht, document.createTextNode("Hand (6 cards) mode (rooms + floor tiles)."));
  handRow.appendChild(handToggle);

  const consumeFloorsToggle = document.createElement("label");
  consumeFloorsToggle.className = "text-xs flex items-center gap-2 mt-2";
  consumeFloorsToggle.style.display = useHandMode ? "flex" : "none";
  const cft = document.createElement("input");
  cft.type = "checkbox";
  cft.checked = consumeFloorsForAuto;
  cft.onchange = (e) => { consumeFloorsForAuto = e.target.checked; render(); };
  consumeFloorsToggle.append(cft, document.createTextNode("Consume floor tiles from hand when solver auto-paths (uses Uramot as wildcard if missing)."));
  handRow.appendChild(consumeFloorsToggle);

  const handGrid = document.createElement("div");
  handGrid.className = "grid grid-cols-3 gap-2 mt-2";
  handGrid.style.display = useHandMode ? "grid" : "none";

  const roomKeys = Object.keys(ROOM_NAMES);
  const floorKeys = FLOOR_TILES.map(f => `FLOOR:${f}`);

  function cardSelect(slot) {
    const sel = document.createElement("select");
    sel.className = "w-full bg-zinc-900 border border-zinc-700 rounded px-2 py-2 text-xs";

    const optEmpty = document.createElement("option");
    optEmpty.value = "";
    optEmpty.textContent = "(empty)";
    sel.appendChild(optEmpty);

    const groupRooms = document.createElement("optgroup");
    groupRooms.label = "Rooms";
    for (const k of roomKeys) {
      const opt = document.createElement("option");
      opt.value = k;
      opt.textContent = ROOM_NAMES[k] || k;
      groupRooms.appendChild(opt);
    }
    sel.appendChild(groupRooms);

    const groupFloors = document.createElement("optgroup");
    groupFloors.label = "Path Tiles (Floors)";
    for (const k of floorKeys) {
      const opt = document.createElement("option");
      opt.value = k;
      opt.textContent = `Path Tile: ${k.slice(6)}`;
      groupFloors.appendChild(opt);
    }
    sel.appendChild(groupFloors);

    sel.value = hand[slot] ?? "";
    sel.onchange = (e) => { hand[slot] = e.target.value || null; render(); };
    return sel;
  }

  for (let i = 0; i < 6; i++) handGrid.appendChild(cardSelect(i));

  const handBtns = document.createElement("div");
  handBtns.className = "flex gap-2 mt-2";
  handBtns.style.display = useHandMode ? "flex" : "none";

  const clearHandBtn = document.createElement("button");
  clearHandBtn.className = "px-3 py-1 bg-zinc-700 rounded text-xs";
  clearHandBtn.textContent = "Clear hand";
  clearHandBtn.onclick = () => { hand = Array(6).fill(null); uiMessage = "Hand cleared."; render(); };
  handBtns.appendChild(clearHandBtn);

  const adviceTitle = document.createElement("div");
  adviceTitle.className = "mt-3 font-semibold text-xs text-emerald-300";
  adviceTitle.textContent = "Advice (click Apply to consume medallions / change board)";

  const adviceList = document.createElement("div");
  adviceList.className = "mt-2 flex flex-col gap-2";

  if (advice.length === 0) {
    const none = document.createElement("div");
    none.className = "text-xs opacity-70";
    none.textContent = "No medallion actions suggested right now.";
    adviceList.appendChild(none);
  } else {
    advice.forEach(a => {
      const item = document.createElement("div");
      item.className = "flex items-center justify-between gap-2 bg-zinc-900 border border-zinc-700 rounded px-2 py-2";

      const txt = document.createElement("div");
      txt.className = "text-xs";
      txt.textContent = a.text;

      const btn = document.createElement("button");
      btn.className = "px-2 py-1 bg-emerald-700 rounded text-xs";
      btn.textContent = "Apply";
      btn.disabled = !a.canApply;
      btn.onclick = () => { a.apply(); render(); };

      item.append(txt, btn);
      adviceList.appendChild(item);
    });
  }

  medBox.append(medTitle, medRow, handRow, handGrid, handBtns, adviceTitle, adviceList);

  /* ---------- Tutorial ---------- */
  const tutBox = document.createElement("div");
  tutBox.className = "mt-3 p-3 bg-zinc-800 rounded border border-zinc-700";

  const tutHeader = document.createElement("button");
  tutHeader.className = "w-full flex items-center justify-between text-left";
  tutHeader.onclick = () => { tutorialOpen = !tutorialOpen; render(); };

  const tutTitle = document.createElement("div");
  tutTitle.className = "font-semibold text-amber-300";
  tutTitle.textContent = "Tutorial / Button Guide (click to toggle)";

  const tutState = document.createElement("div");
  tutState.className = "text-xs opacity-70";
  tutState.textContent = tutorialOpen ? "Hide" : "Show";

  tutHeader.append(tutTitle, tutState);

  const tutBody = document.createElement("div");
  tutBody.style.display = tutorialOpen ? "block" : "none";
  tutBody.className = "mt-2 text-xs leading-relaxed";
  tutBody.innerHTML = `
    <div class="mini">
      <div class="font-semibold text-zinc-100 mb-1">Fixes in this build</div>
      <ul class="list-disc ml-5">
        <li><b>New: Auto-Snake Phase Detection</b>: The solver now scans your board to see if you are already mid-cycle (e.g. just placed Spymaster) and suggests the correct next room immediately.</li>
        <li><b>Quipal crash fixed</b>: no more undefined candidates; capped Quipal suggestions to 10.</li>
        <li><b>+ / – no longer disappear</b>: controls are inside the cell + use opacity instead of display + fixed transform override.</li>
        <li><b>Hand supports floors</b>: you can now put path tiles in your hand and consume them on placement (and optionally for solver auto-pathing).</li>
      </ul>
      <div class="font-semibold text-zinc-100 mt-3 mb-1">Hand mode notes</div>
      <ul class="list-disc ml-5">
        <li>Manual placing a room/floor consumes the matching card from hand, or uses <b>Uramot wildcard</b> if missing.</li>
        <li>If you enable <b>Consume floor tiles for auto-pathing</b>, solver actions will also spend floor cards (or Uramot).</li>
      </ul>
      <div class="font-semibold text-zinc-100 mt-3 mb-1">Tier controls</div>
      <ul class="list-disc ml-5">
        <li><b>Shift+Click</b> tier up, <b>Alt+Click</b> tier down.</li>
        <li>Hover any room tile for the <b>+ / –</b> buttons.</li>
      </ul>
    </div>
  `;

  tutBox.append(tutHeader, tutBody);

  controls.append(row1, row2, status, medBox, tutBox);
  gridCol.appendChild(controls);

  /* ---------- ROOM PALETTE ---------- */
  const roomCol = document.createElement("div");
  roomCol.innerHTML = "<h2 class='font-semibold mb-2'>Rooms</h2>";

  Object.keys(ROOM_NAMES).forEach(r => {
    const b = document.createElement("button");
    b.className = "flex gap-2 items-center px-3 py-2 rounded bg-zinc-700 w-full";
    if (selectedRoom === r) b.classList.add("ring-2","ring-emerald-500");

    const img = document.createElement("img");
    img.src = ROOM_ICONS[r];
    img.className = "w-5 h-5";

    b.append(img, ROOM_NAMES[r]);
    b.onclick = () => {
      selectedRoom = selectedRoom === r ? null : r;
      selectedFloor = null;
      render();
    };
    roomCol.appendChild(b);
  });

  /* ---------- ACTIVE BONUSES ---------- */
  const bonusCol = document.createElement("div");
  bonusCol.className = "w-72";
  bonusCol.innerHTML = "<h2 class='font-semibold mb-2'>Active Bonuses (Connected Only)</h2>";

  const boosters = {};
  grid.forEach((c, i) => {
    if (!c.room || c.faded) return;
    if (!connected.has(i)) return;
    if (BOOST_RULES[c.room]) boosters[c.room] = (boosters[c.room] || 0) + 1;
  });

  const counts = {};
  grid.forEach((c, i) => {
    if (!c.room || c.faded) return;
    if (!connected.has(i)) return;

    const eff = getEffectiveRoomKey(i) || c.room;
    counts[eff] ??= { flat: 0, percent: 0 };
    counts[eff].flat += 1;
    counts[eff].percent += tierPercentFactor(c.tier || 1);
  });

  const grouped = {};
  const boostReport = [];

  Object.entries(counts).forEach(([room, obj]) => {
    let mult = 1;
    Object.entries(boosters).forEach(([b, n]) => {
      const rule = BOOST_RULES[b];
      if (rule.targets.includes(room)) mult += rule.amount * n;
    });

    if (mult > 1) boostReport.push(`${ROOM_NAMES[room] || room}: +${Math.round((mult - 1) * 100)}% (included on % effects)`);

    formatBonuses(room, obj.percent * mult, obj.flat).forEach(text => {
      const cat = categoryOf(text);
      grouped[cat] ??= [];
      grouped[cat].push(text);
    });
  });

  Object.entries(grouped).forEach(([cat, bonuses]) => {
    const h = document.createElement("h3");
    h.className = "mt-3 font-semibold text-emerald-400";
    h.textContent = cat;
    bonusCol.appendChild(h);
    bonuses.forEach(text => {
      const d = document.createElement("div");
      d.className = "text-sm";
      d.textContent = text;
      bonusCol.appendChild(d);
    });
  });

  if (boostReport.length) {
    const h = document.createElement("h3");
    h.className = "mt-3 font-semibold text-sky-400";
    h.textContent = "Boosted Effects (Already Included)";
    bonusCol.appendChild(h);
    boostReport.forEach(t => {
      const d = document.createElement("div");
      d.className = "text-sm opacity-80";
      d.textContent = t;
      bonusCol.appendChild(d);
    });
  }

  if (Object.keys(grouped).length === 0) {
    const d = document.createElement("div");
    d.className = "text-sm opacity-60";
    d.textContent = "No active bonuses (or nothing connected).";
    bonusCol.appendChild(d);
  }

  container.append(gridCol, roomCol, bonusCol);
  app.appendChild(container);
}

render();
</script>
</body>
</html>
