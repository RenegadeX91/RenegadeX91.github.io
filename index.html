```html
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Temple Tile Simulator</title>
<script src="https://cdn.tailwindcss.com"></script>

<style>
  .cell {
    position: relative;
    width: 3rem;
    height: 3rem;
    background: #27272a;
    border-radius: 0.5rem;
  }

  .floor {
    position: absolute;
    inset: 0;
    border: 3px solid #98854d;
    border-radius: 0.5rem;
    background: #372f21;
    z-index: 1;
  }

  .open-U { border-top-color: transparent; }
  .open-R { border-right-color: transparent; }
  .open-D { border-bottom-color: transparent; }
  .open-L { border-left-color: transparent; }

  .room {
    position: absolute;
    inset: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 2;
    pointer-events: none;
  }

  .room img {
    width: 100%;
    height: 100%;
    object-fit: contain;
  }

  .faded {
    opacity: 0.6;
    filter: saturate(0.7);
  }

  .badge {
    position: absolute;
    top: -7px;
    left: -7px;
    z-index: 3;
    font-size: 10px;
    line-height: 1;
    padding: 3px 6px;
    border-radius: 999px;
    border: 1px solid rgba(255,255,255,0.25);
    background: rgba(0,0,0,0.55);
    color: rgba(255,255,255,0.85);
    pointer-events: none;
  }

  .badge-tier {
    position: absolute;
    bottom: -7px;
    right: -7px;
    z-index: 3;
    font-size: 10px;
    line-height: 1;
    padding: 3px 6px;
    border-radius: 999px;
    border: 1px solid rgba(255,255,255,0.25);
    background: rgba(0,0,0,0.55);
    color: rgba(255,255,255,0.9);
    pointer-events: none;
  }

  .badge-q {
    position: absolute;
    top: -7px;
    right: -7px;
    z-index: 3;
    font-size: 10px;
    line-height: 1;
    padding: 3px 6px;
    border-radius: 999px;
    border: 1px solid rgba(255,255,255,0.25);
    background: rgba(0,0,0,0.55);
    color: rgba(255,255,255,0.85);
    pointer-events: none;
  }

  /* =========================
     Diamond / 45° grid view
     ========================= */
  #grid-rot-wrap {
    padding: 80px; /* prevents diamond clipping */
    display: flex;
    justify-content: center;
    align-items: center;
  }

  #temple-grid {
    transform: rotate(45deg);
    transform-origin: center;
  }

  /* Keep icons/badges upright */
  #temple-grid .room,
  #temple-grid .badge,
  #temple-grid .badge-tier,
  #temple-grid .badge-q {
    transform: rotate(-45deg);
    transform-origin: center;
  }

  .mini {
    font-size: 12px;
    opacity: 0.85;
  }
</style>
</head>

<body class="bg-zinc-900 text-zinc-100">
<div id="app" class="p-6"></div>

<script>
const GRID_SIZE = 9;
let selectedRoom = null;
let selectedFloor = null;
let planningMode = false;

const ENTRANCE = { r: GRID_SIZE - 1, c: Math.floor(GRID_SIZE / 2) }; // (8,4)
const entranceIndex = () => ENTRANCE.r * GRID_SIZE + ENTRANCE.c;

let uiMessage = "";
let suggestedMove = null; // { kind, index, step, roomKey, fromHand?, useUramot? }
let tutorialOpen = false;

/* ----------------------------
   Medallion + hand state
   ---------------------------- */
let medallions = {
  Jatalot: 0,   // Protect/lock
  Quipal: 0,    // Upgrade +1 tier once per room
  Puaets: 0,    // Reroll hand
  Uramot: 0,    // Place missing room (hand override)
  Zopex: 0,
  Ascappers: 0
};

let useHandMode = false;
// 6-card hand. Values are room keys or null.
let hand = Array(6).fill(null);

/* ----------------------------
   Grid model
   ---------------------------- */
let grid = Array(GRID_SIZE * GRID_SIZE).fill(null).map(() => ({
  room: null,
  floor: null,
  faded: false,
  tier: 1,          // I/II/III
  locked: false,    // Jatalot lock
  quipalUsed: false // can only apply Quipal once per room
}));

const FLOOR_TILES = [
  "U","R","D","L",
  "UR","RD","DL","LU","UD","LR",
  "URD","RDL","DLU","LUR",
  "URDL"
];

const FLOOR_KEY_TO_TILE = (() => {
  const map = {};
  for (const t of FLOOR_TILES) {
    const key = [...t].sort().join("");
    map[key] = t;
  }
  return map;
})();

const ROOM_NAMES = {
  Spymaster:"Spymaster",
  Garrison:"Garrison",
  LegionBarrack:"Legion Barracks",
  Commander:"Commander",
  FleshSurgeon:"Flesh Surgeon",
  Smithy:"Smithy",
  Armoury:"Armoury",
  SynthfleshLab:"Synthflesh Lab",
  TranscendentBarracks:"Transcendent Barracks",
  GolemWorks:"Golem Works",
  AlchemyLab:"Alchemy Lab",
  Thaumaturge:"Thaumaturge",
  CorruptionChamber:"Corruption Chamber",
  Generator:"Generator",
  SacrificialChamber:"Sacrificial Chamber",
  SealedVault:"Sealed Vault"
};

const ROOM_ICONS = {
  AlchemyLab:"icons/IconAlchemyLab.webp",
  Armoury:"icons/IconArmoury.webp",
  Commander:"icons/IconCommander.webp",
  CorruptionChamber:"icons/IconCorruption.webp",
  FleshSurgeon:"icons/IconFleshSurgeon.webp",
  Garrison:"icons/IconGarrison.webp",
  Generator:"icons/IconGenerator.webp",
  GolemWorks:"icons/IconGolemWorks.webp",
  SacrificialChamber:"icons/IconSacrificialChamber.webp",
  Smithy:"icons/IconSmithy.webp",
  SynthfleshLab:"icons/IconSynthflesh.webp",
  Thaumaturge:"icons/IconThaumaturge.webp",
  TranscendentBarracks:"icons/IconTranscendentBarracks.webp",
  SealedVault:"icons/IconVault.webp",
  LegionBarrack:"icons/IconViperLegionBarracks.webp",
  Spymaster:"icons/IconViperSpymaster.webp"
};

const ROOM_TILES = {
  Spymaster: { bonuses: ["MEDALLION:HIGH:LOCK"] },
  Garrison: { bonuses: ["20% Monster Packs", "30% Normal Monster Effectiveness"] },
  LegionBarrack: { bonuses: ["60% More Rare Monsters", "MEDALLION:HIGH:ADVANCED"] },
  Commander: { bonuses: ["60% Rare Monster Effectiveness", "MEDALLION:LOW:ADVANCED"] },
  FleshSurgeon: { bonuses: ["40% Unique Monster Effectiveness", "ITEM:Limb Modification"] },
  Smithy: { bonuses: ["60% Chest Item Rarity", "ITEM:Vaal Infuser"] },
  Armoury: { bonuses: ["60% Humanoid Monster Effectiveness"] },
  SynthfleshLab: { bonuses: ["40% Experience"] },
  TranscendentBarracks: { bonuses: ["60% More Magic Monsters"] },
  GolemWorks: { bonuses: ["ADD:High Priest", "MEDALLION:HIGH:ROOM"] },
  AlchemyLab: { bonuses: ["60% Item Rarity", "50% Gold", "ITEM:Core Destabiliser", "MEDALLION:LOW:ROOM"] },
  Thaumaturge: { bonuses: ["ADD:Quadrilla Sergeant", "ITEM:Crystallised Corruption", "MEDALLION:HIGH:ADVANCED"] },
  CorruptionChamber: { bonuses: ["60% Chance Rare Monster +1 Mod", "ADD:Royal Sentinel", "ITEM:Architect's Orb"] },
  Generator: { bonuses: ["60% Construct Monster Effectiveness", "ADD:Corrupted Abomination"] },
  SacrificialChamber: { bonuses: ["60% Increased Rare Chest", "ADD:Unchained Beast", "ITEM:Vaal Cultivation Orb", "MEDALLION:HIGH:ADVANCED"] },
  SealedVault: { bonuses: ["25% Item Rarity"] }
};

/* ---------- BOOST RULES ---------- */
const BOOST_RULES = {
  Spymaster: {
    amount: 0.30,
    targets: ["Garrison", "Commander", "Armoury", "Smithy", "LegionBarrack"]
  },
  Thaumaturge: {
    amount: 0.30,
    targets: ["CorruptionChamber", "SealedVault", "SacrificialChamber"]
  }
};

function roman(n) {
  if (n === 1) return "I";
  if (n === 2) return "II";
  if (n === 3) return "III";
  return String(n);
}
function clampTier(t) { return Math.max(1, Math.min(3, t)); }
function tierPercentFactor(t) {
  if (t === 1) return 0.25;
  if (t === 2) return 0.50;
  return 1.00;
}

function formatBonuses(tileKey, countPercent = 1, countFlat = 1) {
  return ROOM_TILES[tileKey]?.bonuses.map(b => {
    if (b.startsWith("MEDALLION:")) {
      const [, chance, type] = b.split(":");
      return `+${countFlat} ${chance === "HIGH" ? "High" : "Low"} Chance ${type} Medallion`;
    }
    if (b.startsWith("ITEM:")) return `+${countFlat} ${b.slice(5)}`;
    if (b.startsWith("ADD:")) return `Adds ${countFlat} ${b.slice(4)} to map`;
    const m = b.match(/(\d+)%\s*(.*)/);
    if (m) return `${Math.round(parseInt(m[1]) * countPercent)}% ${m[2]}`;
    return b;
  }) ?? [];
}

function categoryOf(text) {
  if (text.includes("Medallion")) return "Medallions";
  if (text.startsWith("+")) return "Items";
  if (text.startsWith("Adds")) return "Map Adds";
  if (text.includes("Monster")) return "Monster";
  return "Other";
}

/* ===============================
   Floor graph helpers
   =============================== */
const DIRS = {
  U: { dr: -1, dc: 0, opp: "D" },
  R: { dr: 0, dc: 1, opp: "L" },
  D: { dr: 1, dc: 0, opp: "U" },
  L: { dr: 0, dc: -1, opp: "R" }
};

function inBounds(r,c) { return r >= 0 && c >= 0 && r < GRID_SIZE && c < GRID_SIZE; }
function idx(r,c) { return r * GRID_SIZE + c; }
function rc(i) { return { r: Math.floor(i / GRID_SIZE), c: i % GRID_SIZE }; }
function opens(floorStr, dir) { return !!floorStr && floorStr.includes(dir); }

function neighborsOfIndex(i) {
  const { r, c } = rc(i);
  const out = [];
  for (const d of ["U","R","D","L"]) {
    const nr = r + DIRS[d].dr;
    const nc = c + DIRS[d].dc;
    if (!inBounds(nr,nc)) continue;
    out.push({ dir: d, index: idx(nr,nc) });
  }
  return out;
}

function floorEdgeExists(a, b) {
  const A = grid[a]?.floor;
  const B = grid[b]?.floor;
  if (!A || !B) return false;

  const ar = rc(a), br = rc(b);
  const dr = br.r - ar.r;
  const dc = br.c - ar.c;

  let dir = null;
  if (dr === -1 && dc === 0) dir = "U";
  else if (dr === 1 && dc === 0) dir = "D";
  else if (dr === 0 && dc === 1) dir = "R";
  else if (dr === 0 && dc === -1) dir = "L";
  else return false;

  const opp = DIRS[dir].opp;
  return opens(A, dir) && opens(B, opp);
}

function graphNeighbors(i) {
  const out = [];
  for (const n of neighborsOfIndex(i)) {
    if (floorEdgeExists(i, n.index)) out.push(n.index);
  }
  return out;
}

function connectedFromEntrance() {
  const start = entranceIndex();
  const visited = new Set([start]);
  const q = [start];
  while (q.length) {
    const cur = q.shift();
    for (const nxt of graphNeighbors(cur)) {
      if (visited.has(nxt)) continue;
      visited.add(nxt);
      q.push(nxt);
    }
  }
  return visited;
}

function entranceHasLoop() {
  const start = entranceIndex();
  const visited = new Set();
  const parent = new Map();
  const stack = [start];
  parent.set(start, null);

  while (stack.length) {
    const node = stack.pop();
    if (!visited.has(node)) visited.add(node);

    for (const nxt of graphNeighbors(node)) {
      if (!visited.has(nxt)) {
        parent.set(nxt, node);
        stack.push(nxt);
      } else {
        const p = parent.get(node);
        if (p !== nxt) return true;
      }
    }
  }
  return false;
}

function dirsToTileString(dirSet) {
  const key = [...dirSet].sort().join("");
  return FLOOR_KEY_TO_TILE[key] ?? null;
}

function addOpen(i, dir) {
  const cur = grid[i].floor;
  const set = new Set(cur ? [...cur] : []);
  set.add(dir);
  grid[i].floor = dirsToTileString(set);
}

function connectCells(a, b) {
  const ar = rc(a), br = rc(b);
  const dr = br.r - ar.r;
  const dc = br.c - ar.c;

  let dir = null;
  if (dr === -1 && dc === 0) dir = "U";
  else if (dr === 1 && dc === 0) dir = "D";
  else if (dr === 0 && dc === 1) dir = "R";
  else if (dr === 0 && dc === -1) dir = "L";
  if (!dir) return;

  addOpen(a, dir);
  addOpen(b, DIRS[dir].opp);
}

/* ===============================
   Spymaster conversion
   =============================== */
function isActiveRoom(i, key) { return grid[i].room === key && !grid[i].faded; }
function hasActiveAdjacent(i, key) {
  for (const n of neighborsOfIndex(i)) if (isActiveRoom(n.index, key)) return true;
  return false;
}
function getEffectiveRoomKey(i) {
  const cell = grid[i];
  if (!cell.room || cell.faded) return cell.room;
  if (cell.room === "TranscendentBarracks" && hasActiveAdjacent(i, "Spymaster")) return "LegionBarrack";
  return cell.room;
}

/* ===============================
   Hand helpers (optional)
   =============================== */
function handCounts() {
  const m = {};
  for (const x of hand) { if (!x) continue; m[x] = (m[x] || 0) + 1; }
  return m;
}
function consumeFromHand(roomKey) {
  for (let i = 0; i < hand.length; i++) {
    if (hand[i] === roomKey) { hand[i] = null; return true; }
  }
  return false;
}

/* ===============================
   Auto-solvers paths
   =============================== */
const SNAKE_PATTERN = ["Armoury", "TranscendentBarracks", "Spymaster", "TranscendentBarracks"];
let cachedSnake = null;

function getSnakePath() {
  if (cachedSnake) return cachedSnake;

  const cols = [3,2,1,0];
  const path = [];
  let up = true;

  for (const col of cols) {
    if (up) for (let r = GRID_SIZE - 1; r >= 0; r--) path.push(idx(r, col));
    else for (let r = 0; r < GRID_SIZE; r++) path.push(idx(r, col));
    up = !up;
  }

  cachedSnake = path.filter(i => i !== entranceIndex());
  return cachedSnake;
}
function expectedSnakeRoom(step) { return SNAKE_PATTERN[step % SNAKE_PATTERN.length]; }
function snakeFirstEmptyStep() {
  const path = getSnakePath();
  for (let step = 0; step < path.length; step++) if (!grid[path[step]].room) return step;
  return null;
}
function ensureSnakeFloors(uptoStepInclusive) {
  const path = getSnakePath();
  if (uptoStepInclusive === null || uptoStepInclusive < 0) return;
  connectCells(entranceIndex(), path[0]);
  for (let step = 0; step < uptoStepInclusive; step++) connectCells(path[step], path[step + 1]);
}
function validateSnakePrefix() {
  const path = getSnakePath();
  const mismatches = [];
  for (let step = 0; step < path.length; step++) {
    const i = path[step];
    const room = grid[i].room;
    if (!room) break;
    const exp = expectedSnakeRoom(step);
    if (room !== exp) mismatches.push({ step, index: i, expected: exp, found: room });
  }
  return mismatches;
}

const CORRUPT_PATTERN = ["Generator", "SacrificialChamber", "Thaumaturge", "CorruptionChamber", "AlchemyLab", "SealedVault"];
let cachedCorrupt = null;

function getCorruptionPath() {
  if (cachedCorrupt) return cachedCorrupt;

  const coords = [
    { r: GRID_SIZE - 1, c: 5 },
    { r: GRID_SIZE - 2, c: 5 },
    { r: GRID_SIZE - 3, c: 5 },
    { r: GRID_SIZE - 4, c: 5 },
    { r: GRID_SIZE - 5, c: 5 },
    { r: GRID_SIZE - 6, c: 5 },
  ];

  cachedCorrupt = coords.filter(p => inBounds(p.r, p.c)).map(p => idx(p.r, p.c)).filter(i => i !== entranceIndex());
  return cachedCorrupt;
}
function expectedCorruptRoom(step) { return CORRUPT_PATTERN[step % CORRUPT_PATTERN.length]; }
function corruptFirstEmptyStep() {
  const path = getCorruptionPath();
  for (let step = 0; step < path.length; step++) if (!grid[path[step]].room) return step;
  return null;
}
function ensureCorruptionFloors(uptoStepInclusive) {
  const path = getCorruptionPath();
  if (uptoStepInclusive === null || uptoStepInclusive < 0) return;
  connectCells(entranceIndex(), path[0]);
  for (let step = 0; step < uptoStepInclusive; step++) connectCells(path[step], path[step + 1]);
}
function validateCorruptionPrefix() {
  const path = getCorruptionPath();
  const mismatches = [];
  for (let step = 0; step < path.length; step++) {
    const i = path[step];
    const room = grid[i].room;
    if (!room) break;
    const exp = expectedCorruptRoom(step);
    if (room !== exp) mismatches.push({ step, index: i, expected: exp, found: room });
  }
  return mismatches;
}

/* ---- Hand-aware suggestions ---- */
function suggestNext(kind) {
  if (kind === "snake") {
    const path = getSnakePath();
    const mismatches = validateSnakePrefix();
    const step = snakeFirstEmptyStep();
    if (step === null) return { ok: false, reason: "Snake path is full." };
    const i = path[step];
    const roomKey = expectedSnakeRoom(step);

    if (useHandMode) {
      const counts = handCounts();
      if ((counts[roomKey] || 0) > 0) return { ok: true, move: { kind, index: i, step, roomKey, fromHand: true }, warn: mismatches.length ? mismatches : null };
      if (medallions.Uramot > 0) return { ok: true, move: { kind, index: i, step, roomKey, useUramot: true }, warn: mismatches.length ? mismatches : null };
      return { ok: false, reason: `Need ${ROOM_NAMES[roomKey]} but it isn't in your hand. Use Puaets to reroll, or Uramot to place anyway.` };
    }

    return { ok: true, move: { kind, index: i, step, roomKey }, warn: mismatches.length ? mismatches : null };
  }

  if (kind === "corrupt") {
    const path = getCorruptionPath();
    const mismatches = validateCorruptionPrefix();
    const step = corruptFirstEmptyStep();
    if (step === null) return { ok: false, reason: "Corruption path is full." };
    const i = path[step];
    const roomKey = expectedCorruptRoom(step);

    if (useHandMode) {
      const counts = handCounts();
      if ((counts[roomKey] || 0) > 0) return { ok: true, move: { kind, index: i, step, roomKey, fromHand: true }, warn: mismatches.length ? mismatches : null };
      if (medallions.Uramot > 0) return { ok: true, move: { kind, index: i, step, roomKey, useUramot: true }, warn: mismatches.length ? mismatches : null };
      return { ok: false, reason: `Need ${ROOM_NAMES[roomKey]} but it isn't in your hand. Use Puaets to reroll, or Uramot to place anyway.` };
    }

    return { ok: true, move: { kind, index: i, step, roomKey }, warn: mismatches.length ? mismatches : null };
  }

  return { ok: false, reason: "Unknown kind" };
}

function setSuggestionOnly(s) {
  if (!s.ok) { uiMessage = s.reason; suggestedMove = null; return; }
  suggestedMove = s.move;

  const warn = s.warn || [];
  if (warn.length) {
    const first = warn[0];
    uiMessage = `Suggested ${s.move.kind} step ${s.move.step + 1}: ${ROOM_NAMES[s.move.roomKey]}. Warning: mismatch at step ${first.step + 1} (expected ${ROOM_NAMES[first.expected]}, found ${ROOM_NAMES[first.found]}).`;
  } else {
    uiMessage = `Suggested ${s.move.kind} step ${s.move.step + 1}: ${ROOM_NAMES[s.move.roomKey]} at (${rc(s.move.index).r},${rc(s.move.index).c}).`;
  }
}

function applySuggestion(s) {
  if (!s.ok) { uiMessage = s.reason; suggestedMove = null; return; }

  suggestedMove = s.move;
  const { kind, index, step, roomKey, fromHand, useUramot } = s.move;

  if (grid[index].room && grid[index].room !== roomKey) {
    uiMessage = `Target cell already has ${ROOM_NAMES[grid[index].room]} (expected ${ROOM_NAMES[roomKey]}). Clear it first.`;
    return;
  }

  if (useHandMode) {
    if (fromHand) {
      if (!consumeFromHand(roomKey)) { uiMessage = `Internal: couldn't consume ${ROOM_NAMES[roomKey]} from hand.`; return; }
    } else if (useUramot) {
      if (medallions.Uramot <= 0) { uiMessage = "No Uramot medallions available."; return; }
      medallions.Uramot -= 1;
    } else {
      uiMessage = "Internal: hand-mode move must be fromHand or useUramot.";
      return;
    }
  }

  grid[index].room = roomKey;
  grid[index].faded = planningMode;
  grid[index].tier = 1;
  grid[index].locked = false;
  grid[index].quipalUsed = false;

  if (kind === "snake") ensureSnakeFloors(step);
  if (kind === "corrupt") ensureCorruptionFloors(step);

  const warn = s.warn || [];
  if (warn.length) {
    const first = warn[0];
    uiMessage = `Placed ${kind} step ${step + 1}, but mismatch earlier at step ${first.step + 1} (expected ${ROOM_NAMES[first.expected]}, found ${ROOM_NAMES[first.found]}).`;
  } else {
    uiMessage = `Placed ${kind} step ${step + 1}: ${ROOM_NAMES[roomKey]} at (${rc(index).r},${rc(index).c}).`;
  }
}

/* ===============================
   Medallion advice engine
   =============================== */
function findIndices(predicate) {
  const out = [];
  for (let i = 0; i < grid.length; i++) if (predicate(i, grid[i])) out.push(i);
  return out;
}

function getMedallionAdvice(connected) {
  const advice = [];

  if (medallions.Jatalot > 0) {
    const snakeRoot = getSnakePath()[0];
    const corruptRoot = getCorruptionPath()[0];

    if (grid[snakeRoot]?.room && !grid[snakeRoot].locked) {
      advice.push({
        key: "lock-snake-root",
        text: `Use Jatalot to LOCK Snake root (${ROOM_NAMES[grid[snakeRoot].room]}) at (${rc(snakeRoot).r},${rc(snakeRoot).c}).`,
        canApply: true,
        apply: () => {
          if (medallions.Jatalot <= 0) return;
          grid[snakeRoot].locked = true;
          medallions.Jatalot -= 1;
          uiMessage = "Locked Snake root (Jatalot).";
        }
      });
    } else if (grid[corruptRoot]?.room && !grid[corruptRoot].locked) {
      advice.push({
        key: "lock-corrupt-root",
        text: `Use Jatalot to LOCK Corruption root (${ROOM_NAMES[grid[corruptRoot].room]}) at (${rc(corruptRoot).r},${rc(corruptRoot).c}).`,
        canApply: true,
        apply: () => {
          if (medallions.Jatalot <= 0) return;
          grid[corruptRoot].locked = true;
          medallions.Jatalot -= 1;
          uiMessage = "Locked Corruption root (Jatalot).";
        }
      });
    }

    const sac = findIndices((i,c) => c.room === "SacrificialChamber" && !c.faded && connected.has(i) && !c.locked)[0];
    if (sac !== undefined) {
      advice.push({
        key: "lock-sac",
        text: `Use Jatalot to LOCK Sacrificial Chamber at (${rc(sac).r},${rc(sac).c}).`,
        canApply: true,
        apply: () => {
          if (medallions.Jatalot <= 0) return;
          grid[sac].locked = true;
          medallions.Jatalot -= 1;
          uiMessage = "Locked Sacrificial Chamber (Jatalot).";
        }
      });
    }
  }

  if (medallions.Quipal > 0) {
    const candidates = [];
    for (let i = 0; i < grid.length; i++) {
      const c = grid[i];
      if (!c.room || c.faded) continue;
      if (!connected.has(i)) continue;
      if ((c.tier || 1) >= 3) continue;
      if (c.quipalUsed) continue;

      const eff = getEffectiveRoomKey(i) || c.room;
      let prio = 999;
      if (eff === "Spymaster") prio = 1;
      else if (eff === "LegionBarrack") prio = 2;
      else if (eff === "SacrificialChamber") prio = 3;
      else if (eff === "Thaumaturge") prio = 4;
      else if (eff === "CorruptionChamber") prio = 5;
      else if (eff === "Armoury") prio = 6;
      else prio = 50;

      candidates.push({ i, prio, eff, tier: c.tier || 1 });
    }
    candidates.sort((a,b) => a.prio - b.prio);

    const max = Math.min(medallions.Quipal, Math.max(1, candidates.length));
    for (let k = 0; k < max; k++) {
      const c = candidates[k];
      advice.push({
        key: `quipal-${c.i}`,
        text: `Use Quipal to upgrade ${ROOM_NAMES[c.eff]} at (${rc(c.i).r},${rc(c.i).c}) from ${roman(c.tier)} → ${roman(c.tier+1)}.`,
        canApply: true,
        apply: () => {
          if (medallions.Quipal <= 0) return;
          if (grid[c.i].quipalUsed) { uiMessage = "Quipal already used on that room."; return; }
          grid[c.i].tier = clampTier((grid[c.i].tier || 1) + 1);
          grid[c.i].quipalUsed = true;
          medallions.Quipal -= 1;
          uiMessage = `Applied Quipal at (${rc(c.i).r},${rc(c.i).c}).`;
        }
      });
    }
  }

  if (useHandMode) {
    const nextSnake = suggestNext("snake");
    const nextCorrupt = suggestNext("corrupt");

    const needSnake = !nextSnake.ok && /Need/.test(nextSnake.reason || "");
    const needCorrupt = !nextCorrupt.ok && /Need/.test(nextCorrupt.reason || "");

    if ((needSnake || needCorrupt) && medallions.Puaets > 0) {
      advice.push({
        key: "puaets-reroll",
        text: "Use Puaets to REROLL your 6 cards (your next required room isn’t in hand).",
        canApply: true,
        apply: () => {
          if (medallions.Puaets <= 0) return;
          medallions.Puaets -= 1;
          hand = Array(6).fill(null);
          uiMessage = "Used Puaets: hand cleared. Enter your new 6 cards.";
        }
      });
    }

    if (medallions.Uramot > 0) {
      const s = suggestNext("snake");
      if (s.ok && s.move.useUramot) {
        advice.push({
          key: "uramot-snake",
          text: `Use Uramot to place ${ROOM_NAMES[s.move.roomKey]} for the Snake even though it isn't in your hand.`,
          canApply: true,
          apply: () => { uiMessage = "Tip: click 'Auto place 1' for Snake to consume Uramot and place the missing tile."; }
        });
      }
      const c = suggestNext("corrupt");
      if (c.ok && c.move.useUramot) {
        advice.push({
          key: "uramot-corrupt",
          text: `Use Uramot to place ${ROOM_NAMES[c.move.roomKey]} for the Corruption package even though it isn't in your hand.`,
          canApply: true,
          apply: () => { uiMessage = "Tip: click 'Auto place 1' for Corruption to consume Uramot and place the missing tile."; }
        });
      }
    }
  }

  return advice;
}

/* ===============================
   Layout helpers
   =============================== */
function clearAllRoomsAndFloors() {
  grid.forEach(c => {
    c.room = null;
    c.floor = null;
    c.faded = false;
    c.tier = 1;
    c.locked = false;
    c.quipalUsed = false;
  });
  suggestedMove = null;
}

function rebuildFloorsForAllPlaced() {
  grid.forEach(c => c.floor = null);

  const sp = getSnakePath();
  let sUpto = -1;
  for (let step = 0; step < sp.length; step++) {
    if (!grid[sp[step]].room) break;
    sUpto = step;
  }
  if (sUpto >= 0) ensureSnakeFloors(sUpto);

  const cp = getCorruptionPath();
  let cUpto = -1;
  for (let step = 0; step < cp.length; step++) {
    if (!grid[cp[step]].room) break;
    cUpto = step;
  }
  if (cUpto >= 0) ensureCorruptionFloors(cUpto);

  uiMessage = "Rebuilt floors for currently filled Snake + Corruption prefixes.";
  suggestedMove = null;
}

/* ===============================
   Save / load (includes medallions + hand)
   =============================== */
function saveLayout() {
  const payload = {
    version: 2,
    grid,
    medallions,
    useHandMode,
    hand,
    planningMode
  };
  navigator.clipboard.writeText(JSON.stringify(payload));
  alert("Layout copied to clipboard");
}

function loadLayout() {
  const input = prompt("Paste layout data:");
  if (!input) return;

  try {
    const parsed = JSON.parse(input);

    if (Array.isArray(parsed) && parsed.length === GRID_SIZE * GRID_SIZE) {
      grid = parsed.map(c => ({
        room: c.room ?? null,
        floor: c.floor ?? null,
        faded: !!c.faded,
        tier: c.tier ?? 1,
        locked: !!c.locked,
        quipalUsed: !!c.quipalUsed
      }));
      uiMessage = "Loaded (legacy) layout.";
      suggestedMove = null;
      render();
      return;
    }

    if (parsed && parsed.grid && Array.isArray(parsed.grid) && parsed.grid.length === GRID_SIZE * GRID_SIZE) {
      grid = parsed.grid.map(c => ({
        room: c.room ?? null,
        floor: c.floor ?? null,
        faded: !!c.faded,
        tier: c.tier ?? 1,
        locked: !!c.locked,
        quipalUsed: !!c.quipalUsed
      }));

      medallions = { ...medallions, ...(parsed.medallions || {}) };
      useHandMode = !!parsed.useHandMode;
      hand = Array.isArray(parsed.hand) ? parsed.hand.slice(0,6).concat(Array(6).fill(null)).slice(0,6) : Array(6).fill(null);
      planningMode = !!parsed.planningMode;

      uiMessage = "Loaded layout.";
      suggestedMove = null;
      render();
    }
  } catch {}
}

/* ===============================
   Render
   =============================== */
function render() {
  const app = document.getElementById("app");
  app.innerHTML = "";

  const container = document.createElement("div");
  container.className = "flex gap-6";

  const connected = connectedFromEntrance();
  const hasLoop = entranceHasLoop();
  const advice = getMedallionAdvice(connected);

  /* ---------- GRID + (NOW) FLOOR PALETTE DIRECTLY UNDER IT ---------- */
  const gridCol = document.createElement("div");

  const gridWrap = document.createElement("div");
  gridWrap.id = "grid-rot-wrap";

  const gridEl = document.createElement("div");
  gridEl.id = "temple-grid";
  gridEl.className = "grid grid-cols-9 gap-2";

  grid.forEach((cell, i) => {
    const btn = document.createElement("button");
    btn.className = "cell";

    if (i === entranceIndex()) btn.classList.add("ring-2","ring-sky-400");
    if (suggestedMove && i === suggestedMove.index) btn.classList.add("ring-2","ring-amber-400");
    if (cell.room && !connected.has(i)) btn.classList.add("ring-2","ring-red-500");

    if (cell.floor) {
      const f = document.createElement("div");
      f.className = "floor " + [...cell.floor].map(d => "open-" + d).join(" ");
      btn.appendChild(f);
    }

    if (cell.room) {
      const eff = getEffectiveRoomKey(i) || cell.room;

      const r = document.createElement("div");
      r.className = "room";
      const img = document.createElement("img");
      img.src = ROOM_ICONS[eff] || ROOM_ICONS[cell.room];
      r.appendChild(img);
      btn.appendChild(r);

      if (cell.locked) {
        const b = document.createElement("div");
        b.className = "badge";
        b.textContent = "LOCK";
        btn.appendChild(b);
      }

      if (cell.quipalUsed) {
        const bq = document.createElement("div");
        bq.className = "badge-q";
        bq.textContent = "Q";
        btn.appendChild(bq);
      }

      const bt = document.createElement("div");
      bt.className = "badge-tier";
      bt.textContent = roman(cell.tier || 1);
      btn.appendChild(bt);

      if (!cell.faded && cell.room === "TranscendentBarracks" && eff === "LegionBarrack") {
        const b2 = document.createElement("div");
        b2.className = "badge";
        b2.style.left = "26px";
        b2.textContent = "LEGION";
        btn.appendChild(b2);
      }
    }

    if (cell.faded) btn.classList.add("faded");

    const eff = getEffectiveRoomKey(i);
    const connText = cell.room ? (connected.has(i) ? "connected" : "DISCONNECTED") : "empty";
    const floorText = cell.floor ? cell.floor : "(no floor)";
    const roomText = cell.room ? ROOM_NAMES[cell.room] : "(no room)";
    const effText = (cell.room && eff && eff !== cell.room) ? ` (effective: ${ROOM_NAMES[eff]})` : "";
    const lockText = cell.locked ? "LOCKED" : "unlocked";
    btn.title = `${roomText}${effText}\nTier: ${roman(cell.tier || 1)}\n${lockText}\nFloor: ${floorText}\nStatus: ${connText}\nPos: (${rc(i).r},${rc(i).c})\n\nControls:\n- Shift+Click: tier up\n- Alt+Click: tier down\n- Right-click: clear (Shift+Right-click clears even if locked)`;

    // ✅ FIXED: tier editing always wins even if you have room/floor selected
    btn.onclick = (e) => {
      if (cell.room && (e.shiftKey || e.altKey)) {
        if (e.shiftKey) {
          cell.tier = clampTier((cell.tier || 1) + 1);
          uiMessage = `Tier up: (${rc(i).r},${rc(i).c}) is now ${roman(cell.tier)}.`;
        } else if (e.altKey) {
          cell.tier = clampTier((cell.tier || 1) - 1);
          uiMessage = `Tier down: (${rc(i).r},${rc(i).c}) is now ${roman(cell.tier)}.`;
        }
        suggestedMove = null;
        render();
        return;
      }

      if (selectedRoom) {
        cell.room = selectedRoom;
        cell.faded = planningMode;
        cell.tier = 1;
        cell.locked = false;
        cell.quipalUsed = false;
        suggestedMove = null;
      } else if (selectedFloor) {
        cell.floor = selectedFloor;
        suggestedMove = null;
      } else {
        cell.faded = !cell.faded;
      }
      render();
    };

    btn.oncontextmenu = e => {
      e.preventDefault();

      if (cell.locked && !e.shiftKey) {
        uiMessage = "That room is LOCKED. Shift+Right-click to clear anyway.";
        render();
        return;
      }

      cell.room = null;
      cell.floor = null;
      cell.faded = false;
      cell.tier = 1;
      cell.locked = false;
      cell.quipalUsed = false;
      suggestedMove = null;
      render();
    };

    gridEl.appendChild(btn);
  });

  gridWrap.appendChild(gridEl);
  gridCol.appendChild(gridWrap);

  // ✅ MOVED: FLOOR PALETTE is now directly under the grid
  const floorWrap = document.createElement("div");
  floorWrap.className = "mt-2 text-center";

  const floorTitle = document.createElement("div");
  floorTitle.className = "text-xs opacity-80 mb-2";
  floorTitle.textContent = "Pathing tiles (floors)";

  const floorGrid = document.createElement("div");
  floorGrid.className = "grid grid-cols-5 gap-2 justify-center";

  FLOOR_TILES.forEach(f => {
    const b = document.createElement("button");
    b.className = "cell";
    if (selectedFloor === f) b.classList.add("ring-2","ring-emerald-500");

    const d = document.createElement("div");
    d.className = "floor " + [...f].map(x => "open-" + x).join(" ");
    b.appendChild(d);

    b.onclick = () => {
      selectedFloor = selectedFloor === f ? null : f;
      selectedRoom = null;
      render();
    };

    floorGrid.appendChild(b);
  });

  floorWrap.append(floorTitle, floorGrid);
  gridCol.appendChild(floorWrap);

  /* ---------- CONTROLS ---------- */
  const controls = document.createElement("div");
  controls.className = "flex flex-col gap-2 mt-3";

  const row1 = document.createElement("div");
  row1.className = "flex gap-2 flex-wrap";

  const saveBtn = document.createElement("button");
  saveBtn.textContent = "Save";
  saveBtn.className = "px-3 py-1 bg-zinc-700 rounded";
  saveBtn.onclick = saveLayout;

  const loadBtn = document.createElement("button");
  loadBtn.textContent = "Load";
  loadBtn.className = "px-3 py-1 bg-zinc-700 rounded";
  loadBtn.onclick = loadLayout;

  const planning = document.createElement("label");
  planning.className = "flex items-center gap-2 text-sm px-2";
  const cb = document.createElement("input");
  cb.type = "checkbox";
  cb.checked = planningMode;
  cb.onchange = e => { planningMode = e.target.checked; render(); };
  planning.append(cb, document.createTextNode("Planning mode"));

  const resetBtn = document.createElement("button");
  resetBtn.textContent = "Clear all";
  resetBtn.className = "px-3 py-1 bg-zinc-700 rounded";
  resetBtn.onclick = () => { clearAllRoomsAndFloors(); uiMessage = "Cleared all rooms and floors."; render(); };

  row1.append(saveBtn, loadBtn, planning, resetBtn);

  const row2 = document.createElement("div");
  row2.className = "flex gap-2 flex-wrap items-center";

  const snakeLabel = document.createElement("div");
  snakeLabel.className = "text-sm font-semibold text-emerald-300";
  snakeLabel.textContent = "Spymaster Snake:";

  const snakeSuggestBtn = document.createElement("button");
  snakeSuggestBtn.textContent = "Suggest";
  snakeSuggestBtn.className = "px-3 py-1 bg-emerald-700 rounded";
  snakeSuggestBtn.onclick = () => { setSuggestionOnly(suggestNext("snake")); render(); };

  const snakeStepBtn = document.createElement("button");
  snakeStepBtn.textContent = "Auto place 1";
  snakeStepBtn.className = "px-3 py-1 bg-emerald-700 rounded";
  snakeStepBtn.onclick = () => { applySuggestion(suggestNext("snake")); render(); };

  const corruptLabel = document.createElement("div");
  corruptLabel.className = "text-sm font-semibold text-sky-300 ml-2";
  corruptLabel.textContent = "Corruption package:";

  const corruptSuggestBtn = document.createElement("button");
  corruptSuggestBtn.textContent = "Suggest";
  corruptSuggestBtn.className = "px-3 py-1 bg-sky-700 rounded";
  corruptSuggestBtn.onclick = () => { setSuggestionOnly(suggestNext("corrupt")); render(); };

  const corruptStepBtn = document.createElement("button");
  corruptStepBtn.textContent = "Auto place 1";
  corruptStepBtn.className = "px-3 py-1 bg-sky-700 rounded";
  corruptStepBtn.onclick = () => { applySuggestion(suggestNext("corrupt")); render(); };

  const rebuildFloorsBtn = document.createElement("button");
  rebuildFloorsBtn.textContent = "Rebuild floors";
  rebuildFloorsBtn.className = "px-3 py-1 bg-zinc-700 rounded";
  rebuildFloorsBtn.onclick = () => { rebuildFloorsForAllPlaced(); render(); };

  row2.append(
    snakeLabel, snakeSuggestBtn, snakeStepBtn,
    corruptLabel, corruptSuggestBtn, corruptStepBtn,
    rebuildFloorsBtn
  );

  const status = document.createElement("div");
  status.className = "text-xs mt-1 opacity-80";

  const nActiveRooms = grid.filter(c => c.room && !c.faded).length;
  const nConnectedActiveRooms = grid
    .map((c,i) => ({ c, i }))
    .filter(x => x.c.room && !x.c.faded && connected.has(x.i)).length;

  status.innerHTML = `
    <div>
      Entrance: (${ENTRANCE.r},${ENTRANCE.c}) |
      Active rooms: <span class="text-zinc-100">${nActiveRooms}</span> |
      Connected to entrance: <span class="text-zinc-100">${nConnectedActiveRooms}</span> |
      Loop: ${hasLoop ? "<span class='text-red-400 font-semibold'>DETECTED</span>" : "<span class='text-emerald-300'>none</span>"}
    </div>
    <div class="mt-1">${uiMessage ? uiMessage : ""}</div>
    <div class="mt-1">Red outline = room not connected to Entrance (would not “exist” per transcript rule).</div>
    <div class="mt-1">Tier edit: Shift+Click tier up | Alt+Click tier down | LOCK requires Shift+Right-click to clear.</div>
  `;

  /* ---------- Medallions panel ---------- */
  const medBox = document.createElement("div");
  medBox.className = "mt-3 p-3 bg-zinc-800 rounded border border-zinc-700";

  const medTitle = document.createElement("div");
  medTitle.className = "font-semibold mb-2 text-amber-300";
  medTitle.textContent = "Medallions (Loadout + Advice)";

  const medRow = document.createElement("div");
  medRow.className = "grid grid-cols-2 gap-2";

  function medInput(key, label) {
    const wrap = document.createElement("label");
    wrap.className = "text-xs flex items-center justify-between gap-2 bg-zinc-900 border border-zinc-700 rounded px-2 py-2";
    const t = document.createElement("div");
    t.textContent = label;

    const inp = document.createElement("input");
    inp.type = "number";
    inp.min = "0";
    inp.value = String(medallions[key] ?? 0);
    inp.className = "w-20 px-2 py-1 bg-zinc-800 rounded border border-zinc-700 text-xs";
    inp.onchange = (e) => {
      medallions[key] = Math.max(0, parseInt(e.target.value || "0", 10));
      render();
    };

    wrap.append(t, inp);
    return wrap;
  }

  medRow.append(
    medInput("Jatalot", "Jatalot (Lock)"),
    medInput("Quipal", "Quipal (+1 Tier)"),
    medInput("Puaets", "Puaets (Reroll Hand)"),
    medInput("Uramot", "Uramot (Place Missing)"),
    medInput("Zopex", "Zopex (Meta)"),
    medInput("Ascappers", "Ascappers (Meta)")
  );

  const handRow = document.createElement("div");
  handRow.className = "mt-3";

  const handToggle = document.createElement("label");
  handToggle.className = "text-xs flex items-center gap-2";
  const ht = document.createElement("input");
  ht.type = "checkbox";
  ht.checked = useHandMode;
  ht.onchange = (e) => { useHandMode = e.target.checked; render(); };
  handToggle.append(ht, document.createTextNode("Hand (6 cards) mode — solver only suggests what you can place (unless Uramot)."));
  handRow.appendChild(handToggle);

  const handGrid = document.createElement("div");
  handGrid.className = "grid grid-cols-3 gap-2 mt-2";
  handGrid.style.display = useHandMode ? "grid" : "none";

  const roomKeys = [null, ...Object.keys(ROOM_NAMES)];
  function roomSelect(slot) {
    const sel = document.createElement("select");
    sel.className = "w-full bg-zinc-900 border border-zinc-700 rounded px-2 py-2 text-xs";
    for (const k of roomKeys) {
      const opt = document.createElement("option");
      opt.value = k ?? "";
      opt.textContent = k ? ROOM_NAMES[k] : "(empty)";
      sel.appendChild(opt);
    }
    sel.value = hand[slot] ?? "";
    sel.onchange = (e) => { hand[slot] = e.target.value || null; render(); };
    return sel;
  }
  for (let i = 0; i < 6; i++) handGrid.appendChild(roomSelect(i));

  const handBtns = document.createElement("div");
  handBtns.className = "flex gap-2 mt-2";
  handBtns.style.display = useHandMode ? "flex" : "none";

  const clearHandBtn = document.createElement("button");
  clearHandBtn.className = "px-3 py-1 bg-zinc-700 rounded text-xs";
  clearHandBtn.textContent = "Clear hand";
  clearHandBtn.onclick = () => { hand = Array(6).fill(null); uiMessage = "Hand cleared."; render(); };
  handBtns.appendChild(clearHandBtn);

  const adviceTitle = document.createElement("div");
  adviceTitle.className = "mt-3 font-semibold text-xs text-emerald-300";
  adviceTitle.textContent = "Advice (click Apply to consume medallions / change board)";

  const adviceList = document.createElement("div");
  adviceList.className = "mt-2 flex flex-col gap-2";

  if (advice.length === 0) {
    const none = document.createElement("div");
    none.className = "text-xs opacity-70";
    none.textContent = "No medallion actions suggested right now.";
    adviceList.appendChild(none);
  } else {
    advice.forEach(a => {
      const item = document.createElement("div");
      item.className = "flex items-center justify-between gap-2 bg-zinc-900 border border-zinc-700 rounded px-2 py-2";

      const txt = document.createElement("div");
      txt.className = "text-xs";
      txt.textContent = a.text;

      const btn = document.createElement("button");
      btn.className = "px-2 py-1 bg-emerald-700 rounded text-xs";
      btn.textContent = "Apply";
      btn.disabled = !a.canApply;
      btn.onclick = () => { a.apply(); render(); };

      item.append(txt, btn);
      adviceList.appendChild(item);
    });
  }

  medBox.append(medTitle, medRow, handRow, handGrid, handBtns, adviceTitle, adviceList);

  /* ---------- Tutorial ---------- */
  const tutBox = document.createElement("div");
  tutBox.className = "mt-3 p-3 bg-zinc-800 rounded border border-zinc-700";

  const tutHeader = document.createElement("button");
  tutHeader.className = "w-full flex items-center justify-between text-left";
  tutHeader.onclick = () => { tutorialOpen = !tutorialOpen; render(); };

  const tutTitle = document.createElement("div");
  tutTitle.className = "font-semibold text-amber-300";
  tutTitle.textContent = "Tutorial / Button Guide (click to toggle)";

  const tutState = document.createElement("div");
  tutState.className = "text-xs opacity-70";
  tutState.textContent = tutorialOpen ? "Hide" : "Show";

  tutHeader.append(tutTitle, tutState);

  const tutBody = document.createElement("div");
  tutBody.style.display = tutorialOpen ? "block" : "none";
  tutBody.className = "mt-2 text-xs leading-relaxed";
  tutBody.innerHTML = `
    <div class="mini">
      <div class="font-semibold text-zinc-100 mb-1">Tier edit fix</div>
      <div>Tier edits now work even if you have a room/floor selected. Use <b>Shift</b> (up) and <b>Alt</b> (down).</div>

      <div class="font-semibold text-zinc-100 mt-3 mb-1">Step-by-step</div>
      <ol class="list-decimal ml-5">
        <li>Set your <b>Medallion loadout</b> (Jatalot / Quipal are the big ones).</li>
        <li>(Optional) Enable <b>Hand mode</b> and enter your 6 drawn cards.</li>
        <li>Use <b>Suggest</b> then <b>Auto place 1</b> to grow Snake + Corruption without loops.</li>
        <li>Apply medallion actions from the <b>Advice</b> list.</li>
      </ol>

      <div class="font-semibold text-zinc-100 mt-3 mb-1">Buttons</div>
      <ul class="list-disc ml-5">
        <li><b>Suggest</b>: highlights next intended placement.</li>
        <li><b>Auto place 1</b>: places it, builds floors, consumes hand/Uramot if enabled.</li>
        <li><b>Rebuild floors</b>: recreates floor corridors for current prefixes.</li>
      </ul>
    </div>
  `;

  tutBox.append(tutHeader, tutBody);

  controls.append(row1, row2, status, medBox, tutBox);
  gridCol.appendChild(controls);

  /* ---------- ROOM PALETTE ---------- */
  const roomCol = document.createElement("div");
  roomCol.innerHTML = "<h2 class='font-semibold mb-2'>Rooms</h2>";

  Object.keys(ROOM_NAMES).forEach(r => {
    const b = document.createElement("button");
    b.className = "flex gap-2 items-center px-3 py-2 rounded bg-zinc-700 w-full";
    if (selectedRoom === r) b.classList.add("ring-2","ring-emerald-500");

    const img = document.createElement("img");
    img.src = ROOM_ICONS[r];
    img.className = "w-5 h-5";

    b.append(img, ROOM_NAMES[r]);
    b.onclick = () => {
      selectedRoom = selectedRoom === r ? null : r;
      selectedFloor = null;
      render();
    };
    roomCol.appendChild(b);
  });

  /* ---------- ACTIVE BONUSES ---------- */
  const bonusCol = document.createElement("div");
  bonusCol.className = "w-72";
  bonusCol.innerHTML = "<h2 class='font-semibold mb-2'>Active Bonuses (Connected Only)</h2>";

  const boosters = {};
  grid.forEach((c, i) => {
    if (!c.room || c.faded) return;
    if (!connected.has(i)) return;
    if (BOOST_RULES[c.room]) boosters[c.room] = (boosters[c.room] || 0) + 1;
  });

  const counts = {};
  grid.forEach((c, i) => {
    if (!c.room || c.faded) return;
    if (!connected.has(i)) return;

    const eff = getEffectiveRoomKey(i) || c.room;
    counts[eff] ??= { flat: 0, percent: 0 };
    counts[eff].flat += 1;
    counts[eff].percent += tierPercentFactor(c.tier || 1);
  });

  const grouped = {};
  const boostReport = [];

  Object.entries(counts).forEach(([room, obj]) => {
    let mult = 1;
    Object.entries(boosters).forEach(([b, n]) => {
      const rule = BOOST_RULES[b];
      if (rule.targets.includes(room)) mult += rule.amount * n;
    });

    if (mult > 1) boostReport.push(`${ROOM_NAMES[room]}: +${Math.round((mult - 1) * 100)}% (included on % effects)`);

    formatBonuses(room, obj.percent * mult, obj.flat).forEach(text => {
      const cat = categoryOf(text);
      grouped[cat] ??= [];
      grouped[cat].push(text);
    });
  });

  Object.entries(grouped).forEach(([cat, bonuses]) => {
    const h = document.createElement("h3");
    h.className = "mt-3 font-semibold text-emerald-400";
    h.textContent = cat;
    bonusCol.appendChild(h);
    bonuses.forEach(text => {
      const d = document.createElement("div");
      d.className = "text-sm";
      d.textContent = text;
      bonusCol.appendChild(d);
    });
  });

  if (boostReport.length) {
    const h = document.createElement("h3");
    h.className = "mt-3 font-semibold text-sky-400";
    h.textContent = "Boosted Effects (Already Included)";
    bonusCol.appendChild(h);
    boostReport.forEach(t => {
      const d = document.createElement("div");
      d.className = "text-sm opacity-80";
      d.textContent = t;
      bonusCol.appendChild(d);
    });
  }

  if (Object.keys(grouped).length === 0) {
    const d = document.createElement("div");
    d.className = "text-sm opacity-60";
    d.textContent = "No active bonuses (or nothing connected).";
    bonusCol.appendChild(d);
  }

  container.append(gridCol, roomCol, bonusCol);
  app.appendChild(container);
}

render();
</script>
</body>
</html>
```
